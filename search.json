[{"path":"https://docs.ropensci.org/chopin/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to chopin","title":"Contributing to chopin","text":"outlines propose change chopin.","code":""},{"path":"https://docs.ropensci.org/chopin/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to chopin","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"https://docs.ropensci.org/chopin/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to chopin","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed). See tidyverse team’s guide create great issue advice. adding new function package, always add working examples new function roxygen2 documentation #' @examples.","code":""},{"path":"https://docs.ropensci.org/chopin/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to chopin","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"NIEHS/chopin\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header).","code":""},{"path":"https://docs.ropensci.org/chopin/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to chopin","text":"Please abide 80-character line rules (default settings lintr) use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"https://docs.ropensci.org/chopin/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to chopin","text":"Please note chopin project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://docs.ropensci.org/chopin/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 chopin authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v01_start.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting started with chopin","text":"chopin automatically distributes geospatial data computation multiple threads. Function centered workflow streamline process parallelizing geospatial computation minimal effort.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v01_start.html","id":"chopin-workflow","dir":"Articles","previous_headings":"","what":"chopin workflow","title":"Getting started with chopin","text":"simplest way parallelizing generic geospatial computation start par_pad_* functions par_grid, running par_hierarchy, par_multirasters functions .","code":"library(chopin) library(terra) library(sf) library(collapse) library(dplyr) library(future) library(future.mirai) library(future.apply)"},{"path":"https://docs.ropensci.org/chopin/articles/v01_start.html","id":"example-data","dir":"Articles","previous_headings":"","what":"Example data","title":"Getting started with chopin","text":"North Carolinian counties raster elevation data used example data.","code":"nccnty_path <- system.file(\"extdata\", \"nc_hierarchy.gpkg\", package = \"chopin\") ncelev_path <-   system.file(\"extdata/nc_srtm15_otm.tif\", package = \"chopin\") nccnty <- terra::vect(nccnty_path)  ncelev <- terra::rast(ncelev_path)"},{"path":"https://docs.ropensci.org/chopin/articles/v01_start.html","id":"generating-random-points-in-north-carolina","dir":"Articles","previous_headings":"Example data","what":"Generating random points in North Carolina","title":"Getting started with chopin","text":"demonstrate chopin functions, generate 10,000 random points North Carolina","code":"ncsamp <-   terra::spatSample(     nccnty,     1e4L   ) ncsamp$pid <- 1:nrow(ncsamp)"},{"path":"https://docs.ropensci.org/chopin/articles/v01_start.html","id":"creating-grids","dir":"Articles","previous_headings":"","what":"Creating grids","title":"Getting started with chopin","text":"example generate regular grid random point data.","code":"ncgrid <- par_pad_grid(ncsamp, mode = \"grid\", nx = 4L, ny = 2L, padding = 10000)  plot(ncgrid$original)"},{"path":"https://docs.ropensci.org/chopin/articles/v01_start.html","id":"extracting-values-from-raster","dir":"Articles","previous_headings":"","what":"Extracting values from raster","title":"Getting started with chopin","text":"Since par_* functions operate future backends, users define future plan running functions. multicore plan supports terra objects may lead faster computation, supported Windows. alternative future.mirai’s mirai_multisession plan, supported many platforms generally faster plain future multisession plan. workers argument defined integer value specify number threads used. dispatch multiple extract_at runs grid polygons. proceed, terra object converted sf object.","code":"future::plan(future.mirai::mirai_multisession, workers = 2L) pg <-   par_grid(     grids = ncgrid,     pad_y = FALSE,     .debug = TRUE,     fun_dist = extract_at,     x = ncelev_path,     y = sf::st_as_sf(ncsamp),     id = \"pid\",     radius = 1e4,     func = \"mean\"   )"},{"path":"https://docs.ropensci.org/chopin/articles/v01_start.html","id":"hierarchical-processing","dir":"Articles","previous_headings":"","what":"Hierarchical processing","title":"Getting started with chopin","text":"demonstrate hierarchical processing random points using census tract polygons. example parallelize summarizing mean elevation 10 kilometers circular buffers random sample points first five characters census tract unique identifiers, county codes. example demonstrates hierarchy can defined given polygons unique identifiers suitably formatted defining hierarchy.","code":"nccnty <- sf::st_read(nccnty_path, layer = \"county\") ## Reading layer `county' from data source  ##   `/usr/local/lib/R/site-library/chopin/extdata/nc_hierarchy.gpkg'  ##   using driver `GPKG' ## Simple feature collection with 100 features and 1 field ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 ## Projected CRS: NAD83 / Conus Albers nctrct <- sf::st_read(nccnty_path, layer = \"tracts\") ## Reading layer `tracts' from data source  ##   `/usr/local/lib/R/site-library/chopin/extdata/nc_hierarchy.gpkg'  ##   using driver `GPKG' ## Simple feature collection with 2672 features and 1 field ## Geometry type: MULTIPOLYGON ## Dimension:     XY ## Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 ## Projected CRS: NAD83 / Conus Albers px <-   par_hierarchy(     # from here the par_hierarchy-specific arguments     regions = nctrct,     regions_id = \"GEOID\",     length_left = 5,     pad = 10000,     pad_y = FALSE,     .debug = TRUE,     # from here are the dispatched function definition     # for parallel workers     fun_dist = extract_at,     # below should follow the arguments of the dispatched function     x = ncelev,     y = sf::st_as_sf(ncsamp),     id = \"pid\",     radius = 1e4,     func = \"mean\"   )  dim(px) ## [1] 10000     2 head(px) ##   pid      mean ## 1  79 13.664886 ## 2 198  7.980108 ## 3 337 12.189816 ## 4 454  2.763836 ## 5 467 19.170189 ## 6 485 13.523435 tail(px) ##        pid      mean ## 9995  9542 -1.184563 ## 9996  9703  5.548240 ## 9997  9756  5.548804 ## 9998  9759  6.540437 ## 9999  9841  6.414054 ## 10000 9963  4.990165"},{"path":"https://docs.ropensci.org/chopin/articles/v01_start.html","id":"multiraster-processing","dir":"Articles","previous_headings":"","what":"Multiraster processing","title":"Getting started with chopin","text":"demonstrate multiraster processing random points using multiple rasters.","code":"ncelev <-   system.file(\"extdata/nc_srtm15_otm.tif\", package = \"chopin\") ncelev <- terra::rast(ncelev) tdir <- tempdir(check = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test1.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test2.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test3.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test4.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test5.tif\"), overwrite = TRUE)  rasts <- list.files(tdir, pattern = \"tif$\", full.names = TRUE)  pm <-   par_multirasters(     filenames = rasts,     fun_dist = extract_at,     x = NA,     y = sf::st_as_sf(ncsamp)[1:500, ],     id = \"pid\",     radius = 1e4,     func = \"mean\",     .debug = TRUE   )  dim(pm) ## [1] 2500    2 head(pm) ##          mean               base_raster ## 1   12.443567 /tmp/RtmpvyLHDS/test1.tif ## 2   74.934341 /tmp/RtmpvyLHDS/test1.tif ## 3  179.088806 /tmp/RtmpvyLHDS/test1.tif ## 4    8.542515 /tmp/RtmpvyLHDS/test1.tif ## 5 1087.089722 /tmp/RtmpvyLHDS/test1.tif ## 6  110.032043 /tmp/RtmpvyLHDS/test1.tif tail(pm) ##            mean               base_raster ## 2495 101.370438 /tmp/RtmpvyLHDS/test5.tif ## 2496  -2.881788 /tmp/RtmpvyLHDS/test5.tif ## 2497   7.347102 /tmp/RtmpvyLHDS/test5.tif ## 2498   8.790645 /tmp/RtmpvyLHDS/test5.tif ## 2499  21.443277 /tmp/RtmpvyLHDS/test5.tif ## 2500  56.097313 /tmp/RtmpvyLHDS/test5.tif"},{"path":[]},{"path":"https://docs.ropensci.org/chopin/articles/v01_start.html","id":"why-parallelization-is-slower-than-the-ordinary-function-run","dir":"Articles","previous_headings":"Caveats","what":"Why parallelization is slower than the ordinary function run?","title":"Getting started with chopin","text":"Parallelization may underperform datasets small take advantage divide--compute approach, parallelization overhead involved. Overhead refers required amount computational resources transferring objects multiple processes. Since demonstrations use quite small datasets, advantage parallelization noticeable expected. large amount data (spatial/temporal resolution number files, example) processed, users find efficiency package. vignette package demonstrates use cases extracting various climate/weather datasets.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v01_start.html","id":"notes-on-data-restrictions","dir":"Articles","previous_headings":"Caveats","what":"Notes on data restrictions","title":"Getting started with chopin","text":"chopin works best two-dimensional (planar) geometries. Users disable s2 spherical geometry mode sf setting sf::sf_use_s2(FALSE). Running chopin functions spherical three-dimensional (e.g., including M/Z dimensions) geometries may produce incorrect unexpected results.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v02_good_practice.html","id":"assumptions","dir":"Articles","previous_headings":"","what":"Assumptions","title":"Good practice of using `chopin`","text":"Users can access multi-threaded central processing units sufficient memory (.e., least 4GB/thread)","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/articles/v02_good_practice.html","id":"minimize-errors","dir":"Articles","previous_headings":"Basic workflow","what":"Minimize errors","title":"Good practice of using `chopin`","text":"Consider using try() tryCatch() let error halt work without results, especially using higher-level functions.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v02_good_practice.html","id":"raster-workflow-stacked-vs-file-based-parallelization","dir":"Articles","previous_headings":"Basic workflow","what":"Raster workflow: stacked vs file-based parallelization","title":"Good practice of using `chopin`","text":"\\[!NOTE\\] ’s users’ system specification size data. faster computation, two strategies. One parallelization implemented chopin example. strategy stack rasters extract values . Adjustment arguments exactextractr::exact_extract benefit many people dealing sizable data able stacked. compare two strategies terms computation time. proceeding, users need consider hardware specification. example, memory storage leverage maximal performance exact_extract. Specifically speaking, memory capacity crucial store stacked rasters memory rather read proxy rasters disk implemented terra. max_cells_in_memory key argument control memory usage. maximum possible value argument \\(2^{31} - 1 = 2,147,483,647\\), roughly 2.147e9, applied example . memory bandwidth much faster disk input/output specification, stacked rasters high max_cells_in_memory applied run faster file-based parallelization extraction lower value max_cells_in_memory. performance come without cost. memory-intensive setting suitable system limited memory, example, consumer laptops around 16 GB RAM. \\[!NOTE\\] Stacking rasters usually takes large amount memory. Users need consider memory capacity system stacking rasters.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v02_good_practice.html","id":"raster-vector-overlay","dir":"Articles","previous_headings":"Basic workflow","what":"Raster-Vector overlay","title":"Good practice of using `chopin`","text":"Use chopin::par_pad_grid() make exhaustive (fully filling entire extent without gaps) padded grid objects SpatVector class. chopin::par_grid() filters features intersect grid. Post-processing necessary polygons may taken twice parallelized calculation. users field containing divisible hierarchical information, dataset can processed chopin::par_hierarchy().","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v02_good_practice.html","id":"customization","dir":"Articles","previous_headings":"Basic workflow","what":"Customization","title":"Good practice of using `chopin`","text":"chopin way parallelize iterate calculation list use future.apply function. one wants customize parallelization workflow like chopin, consider making list objects two steps. First, assign extent vectors element. case, users aware coordinate system input data coordinates extent vectors. Second, use preprocessed vector objects respect extent vector first list. recommend name list element debug easily. par_multirasters() workflow, using file database table paths recommended instead SpatRaster objects future parallel processing workflow. SpatRaster objects made external files Rcpp pointers, exported processes parallelization.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v02_good_practice.html","id":"more-tips-to-save-time-and-memory","dir":"Articles","previous_headings":"Basic workflow","what":"More tips to save time and memory","title":"Good practice of using `chopin`","text":"Read vector data sf package first. bit faster terra save time processing exactextractr designed work sf objects vector inputs. analysis require high precision vector data, simplification geometries (e.g., using rmapshaper, .e., ms_simplify) result considerable time savings.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v02_good_practice.html","id":"save-computing-costs","dir":"Articles","previous_headings":"Basic workflow","what":"Save computing costs","title":"Good practice of using `chopin`","text":"HPC systems used, CPU-memory usage quota per user. Thus, always recommended test computation workflow subsets manageable sizes. can give estimate total computational demand. profvis::profvis() helps summarize runtime per function call memory usage. testing, use future::plan(future::sequential) see single-thread. Keep chopin::par_pad_grid() arguments take one two grids using lapply. Preferably hardest case tested estimate maximum peak memory usage per thread. prototyping, take numbers reference numbers submit job HPC proper amount computational assets: HPC management system offers tools see statistics task summaries. Users advised use records plan asset allocation next time.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v03_par_pad_grid.html","id":"computational-grids","dir":"Articles","previous_headings":"","what":"Computational grids","title":"Generate computational grids","text":"Computational grids refer set polygons cover entire spatial domain interest. grids used split spatial domain smaller pieces parallel processing. chopin provides functions generate computational grids parallel processing par_grid() function. Generate computational grids par_pad_grid() par_pad_balanced(). step give set grid polygons, one original splits padded consideration buffer radius subsequent spatial operations. Run par_grid() input dataset grid polygons. Input data: data computed value stored. example, extracting raster values vector objects, vector objects input data. Target data: data values come. example , raster object target data. Original padded grids used split main input original grid target dataset computation padded grid, respectively.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v03_par_pad_grid.html","id":"types-of-computational-grids-and-their-generation","dir":"Articles","previous_headings":"","what":"Types of computational grids and their generation","title":"Generate computational grids","text":"two approaches generate computational grids. One use par_pad_grid() one three modes use par_group_grid(). Thus, users four options total generate computational grids. padding argument important ensure accurate parallel operations case buffering involved. Suppose user point geometry inputs apply circular buffer certain radius. Since original grid (without padding = overlap adjacent grids) filters original input parallel worker, points near grid border may miss target data buffered polygons exceed grid.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v03_par_pad_grid.html","id":"par_pad_grid-standard-interface","dir":"Articles","previous_headings":"Types of computational grids and their generation","what":"par_pad_grid(): standard interface","title":"Generate computational grids","text":"par_pad_grid() generates regular grid polygons padding parallel processing. Padding distance overlapping grid polygons, essentially buffer radius points buffer polygons concerned. mode = \"grid\": generates regular grid polygons padding, nx ny arguments determine number columns rows grid, respectively. mode = \"grid_quantile\": generates regular grid polygons padding based quantiles number points grid. grids look irregular points per grid balanced grid mode. mode = \"grid_advanced\": generates regular grid polygons padding based number points grid number points entire dataset. nx ny arguments determine number columns rows grid, merge_max argument controls many adjacent grids merged one grid. grid_min_features argument determines minimum number points grid, means grids fewer points value merged adjacent grids. Adjusting arguments can balance computational load among threads reduce overhead parallelization.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v03_par_pad_grid.html","id":"par_pad_balanced-focusing-on-getting-the-balanced-clusters","dir":"Articles","previous_headings":"Types of computational grids and their generation","what":"par_pad_balanced(): focusing on getting the balanced clusters","title":"Generate computational grids","text":"par_pad_balanced() groups inputs equal size, generates padded rectangles cover number points per grid. Users can use output function par_grid() parallel processing.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v03_par_pad_grid.html","id":"random-points-in-nc","dir":"Articles","previous_headings":"Types of computational grids and their generation","what":"Random points in NC","title":"Generate computational grids","text":"demonstration par_pad_grid(), use moderately clustered point locations generated inside counties North Carolina.","code":"ncpoly <- system.file(\"shape/nc.shp\", package = \"sf\") ncsf <- sf::read_sf(ncpoly) ncsf <- sf::st_transform(ncsf, \"EPSG:5070\") plot(sf::st_geometry(ncsf)) # sampling clustered point library(spatstat.random) ## Loading required package: spatstat.data ## Loading required package: spatstat.univar ## spatstat.univar 3.1-1 ## Loading required package: spatstat.geom ## spatstat.geom 3.3-5 ##  ## Attaching package: 'spatstat.geom' ## The following objects are masked from 'package:igraph': ##  ##     diameter, edges, is.connected, vertices ## The following objects are masked from 'package:terra': ##  ##     area, delaunay, is.empty, rescale, rotate, shift, where.max, ##     where.min ## spatstat.random 3.3-2 set.seed(202404) ncpoints <-   sf::st_sample(     x = ncsf,     type = \"Thomas\",     mu = 20,     scale = 1e4,     kappa = 1.25e-9   ) ncpoints <- ncpoints[seq_len(2e3L), ]  ncpoints <- sf::st_as_sf(ncpoints) ncpoints <- sf::st_set_crs(ncpoints, \"EPSG:5070\") ncpoints$pid <- sprintf(\"PID-%05d\", seq(1, nrow(ncpoints))) plot(sf::st_geometry(ncpoints)) # convert to terra SpatVector ncpoints_tr <- terra::vect(ncpoints)"},{"path":"https://docs.ropensci.org/chopin/articles/v03_par_pad_grid.html","id":"visualize-computational-grids","dir":"Articles","previous_headings":"","what":"Visualize computational grids","title":"Generate computational grids","text":"output par_pad_grid() par_pad_balanced() length 2 list. significant difference two first element output. par_pad_grid(), always sf SpatVector object polygon geometries. hand, par_pad_balanced() first element sf SpatVector object geometry type original input. example, point geometries input point.","code":"compregions <-   chopin::par_pad_grid(     ncpoints_tr,     mode = \"grid\",     nx = 8L,     ny = 5L,     padding = 1e4L   )  # a list object class(compregions) ## [1] \"list\" # length of 2 names(compregions) ## [1] \"original\" \"padded\" par(mfrow = c(2, 1)) plot(compregions$original, main = \"Original grids\") plot(compregions$padded, main = \"Padded grids\")"},{"path":"https://docs.ropensci.org/chopin/articles/v03_par_pad_grid.html","id":"generate-regular-grid-computational-regions","dir":"Articles","previous_headings":"Visualize computational grids","what":"Generate regular grid computational regions","title":"Generate computational grids","text":"chopin::par_pad_grid() takes spatial dataset generate regular grid polygons nx ny arguments padding. Users overlapping (degree radius) non-overlapping grids, utilized split locations target datasets sub-datasets efficient processing. output par_pad_grid() list object two elements named original (non-overlapping grid polygons) padded (overlapping padding). class element depends input dataset class. figures illustrate grid polygons without overlaps.","code":"compregions <-   chopin::par_pad_grid(     ncpoints_tr,     mode = \"grid\",     nx = 8L,     ny = 5L,     padding = 1e4L   ) names(compregions) ## [1] \"original\" \"padded\" oldpar <- par() par(mfrow = c(2, 1)) terra::plot(compregions$original, main = \"Original grids\") terra::plot(compregions$padded, main = \"Padded grids\") par(mfrow = c(1, 1)) terra::plot(compregions$original, main = \"Original grids\") terra::plot(ncpoints_tr, add = TRUE, col = \"red\", cex = 0.4)"},{"path":"https://docs.ropensci.org/chopin/articles/v03_par_pad_grid.html","id":"split-the-points-by-two-1d-quantiles","dir":"Articles","previous_headings":"Visualize computational grids","what":"Split the points by two 1D quantiles","title":"Generate computational grids","text":"mode = \"grid_quantile\" generates regular grid polygons padding based quantiles coordinates dimension. using mode, users define quantiles argument, used get number quantiles dimension. convenient way define seq() function length.argument. example uses length.= 5, give quartiles.","code":"grid_quantiles <-   chopin::par_pad_grid(     input = ncpoints_tr,     mode = \"grid_quantile\",     quantiles = seq(0, 1, length.out = 5),     padding = 1e4L   )  names(grid_quantiles) ## [1] \"original\" \"padded\" par(mfrow = c(2, 1)) terra::plot(grid_quantiles$original, main = \"Original grids\") terra::plot(grid_quantiles$padded, main = \"Padded grids\") par(mfrow = c(1, 1)) terra::plot(grid_quantiles$original, main = \"Original grids\") terra::plot(ncpoints_tr, add = TRUE, col = \"red\", cex = 0.4)"},{"path":"https://docs.ropensci.org/chopin/articles/v03_par_pad_grid.html","id":"merge-the-grids-based-on-the-number-of-points","dir":"Articles","previous_headings":"Visualize computational grids","what":"Merge the grids based on the number of points","title":"Generate computational grids","text":"mode = \"grid_advanced\" utilizes finer grids merge results finer grids coarser grids. behavior can balance computational load among threads reduce overhead parallelization. said, mode internally generates grids mode = \"grid\" merges based number points grid. determine adjacency merging behavior, minimum spanning tree (MST) identified. function utilizes igraph::mst() MST identification graph summary functions hood. note, users can adjust merging behavior changing arguments grid_min_features merge_max.","code":"grid_advanced1 <-   chopin::par_pad_grid(     input = ncpoints_tr,     mode = \"grid_advanced\",     nx = 15L,     ny = 8L,     padding = 1e4L,     grid_min_features = 25L,     merge_max = 5L   ) ## Switch terra class to sf... ## Switch terra class to sf... ## ℹ The merged polygons have too complex shapes. ## Increase threshold or use the original grids. ##  ## Switch sf class to terra... par(mfrow = c(2, 1)) terra::plot(grid_advanced1$original, main = \"Original grids\") terra::plot(grid_advanced1$padded, main = \"Padded grids\") par(mfrow = c(1, 1)) terra::plot(grid_advanced1$original, main = \"Merged grids (merge_max = 5)\") terra::plot(ncpoints_tr, add = TRUE, col = \"red\", cex = 0.4) ncpoints_tr$n <- 1 n_points <-   terra::zonal(     ncpoints_tr,     grid_advanced1$original,     fun = \"sum\"   )[[\"n\"]]  grid_advanced1g <- grid_advanced1$original grid_advanced1g$n_points <- n_points  terra::plot(grid_advanced1g, \"n_points\", main = \"Number of points in each grid\")"},{"path":"https://docs.ropensci.org/chopin/articles/v03_par_pad_grid.html","id":"different-values-in-merge_max","dir":"Articles","previous_headings":"Visualize computational grids > Merge the grids based on the number of points","what":"Different values in merge_max","title":"Generate computational grids","text":"Keeping arguments , can see difference number merged grids changing merge_max argument.","code":"grid_advanced2 <-   chopin::par_pad_grid(     input = ncpoints_tr,     mode = \"grid_advanced\",     nx = 15L,     ny = 8L,     padding = 1e4L,     grid_min_features = 30L,     merge_max = 4L   ) ## Switch terra class to sf... ## Switch terra class to sf... ## ℹ The merged polygons have too complex shapes. ## Increase threshold or use the original grids. ##  ## Switch sf class to terra... par(mfrow = c(2, 1)) terra::plot(grid_advanced2$original, main = \"Original grids\") terra::plot(grid_advanced2$padded, main = \"Padded grids\") par(mfrow = c(1, 1)) terra::plot(grid_advanced2$original, main = \"Merged grids (merge_max = 8)\") terra::plot(ncpoints_tr, add = TRUE, col = \"red\", cex = 0.4) grid_advanced3 <-   chopin::par_pad_grid(     input = ncpoints_tr,     mode = \"grid_advanced\",     nx = 15L,     ny = 8L,     padding = 1e4L,     grid_min_features = 25L,     merge_max = 3L   ) ## Switch terra class to sf... ## Switch terra class to sf... ## ℹ The merged polygons have too complex shapes. ## Increase threshold or use the original grids. ##  ## Switch sf class to terra... par(mfrow = c(2, 1)) terra::plot(grid_advanced3$original, main = \"Original grids\") terra::plot(grid_advanced3$padded, main = \"Padded grids\") par(mfrow = c(1, 1)) terra::plot(grid_advanced3$original, main = \"Merged grids (merge_max = 3)\") terra::plot(ncpoints_tr, add = TRUE, col = \"red\", cex = 0.4)"},{"path":"https://docs.ropensci.org/chopin/articles/v03_par_pad_grid.html","id":"par_make_balanced","dir":"Articles","previous_headings":"Visualize computational grids > Merge the grids based on the number of points","what":"par_make_balanced()","title":"Generate computational grids","text":"background, par_pad_balanced() run first generate equally sized clusters input. , padding applied extent cluster compatible par_grid(), original padded grids used. Please note ngroups argument value must exact divisor number points. example, example , one changes ngroups 10L, fail number points divisible 10. Consult anticlust package details algorithm. par_pad_balanced() makes compatible object output par_pad_grid() directly input points. illustrated figure , points split ngroups clusters number points processed parallel using output object par_grid().","code":"# ngroups should be the exact divisor of the number of points! group_bal_grid <-   chopin::par_pad_balanced(     points_in = ncpoints_tr,     ngroups = 10L,     padding = 1e4   ) group_bal_grid$original$CGRIDID <- as.factor(group_bal_grid$original$CGRIDID)  par(mfrow = c(2, 1)) terra::plot(group_bal_grid$original, \"CGRIDID\",             legend = FALSE,             main = \"Assigned points (ngroups = 10)\") terra::plot(group_bal_grid$padded, main = \"Padded grids\")"},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"document demonstrates parallelize weather/climate geospatial data processing chopin cases users may take advantage parallel processing . cover following formats: consider TerraClimate PRISM data data format . Parameter-elevation Regressions Independent Slopes Model (PRISM) high-resolution (800-1,000 meters) gridded climate dataset available BIL (band interleaved line) format readable GDAL. TerraClimate high-resolution (5 km) gridded climate dataset NetCDF format readable GDAL. spatial resolution TerraClimate data commensurates 5 km equator, whereas PRISM data approximately 1 km. data available NetCDF format readable GDAL. use terra package read data.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"prepare-target-datasets","dir":"Articles","previous_headings":"Introduction","what":"Prepare target datasets","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"consider populated places centroids mainland United States (.e., excluding Alaska, Hawaii, territories). use tigris package download data.","code":"library(chopin) library(terra) library(sf) library(stars) library(future) library(future.mirai) library(parallelly) library(dplyr) library(tigris) library(tictoc)  options(tigris_use_cache = TRUE, sf_use_s2 = FALSE)"},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"hardware-specification","dir":"Articles","previous_headings":"Introduction","what":"Hardware specification","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"used machine 112 physical CPU cores 750 GB memory, used portion cores (20) demonstration. maximum possible memory usage set. However, typical HPC management systems, users required request number cores memory jobs. number cores memory capacity considered users parallelize extraction process.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"download","dir":"Articles","previous_headings":"Introduction > Download and preprocess","what":"Download","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"","code":"# populated places state <- tigris::states(year = 2022) statemain <-   state[!state$STUSPS %in% c(\"AK\", \"HI\", \"PR\", \"VI\", \"GU\", \"MP\", \"AS\"), ] target_states <- statemain$GEOID  popplace <-   lapply(target_states, function(x) tigris::places(x, year = 2022)) %>%   do.call(rbind, .) saveRDS(popplace, \"./input/populated_place_2022.rds\", compress = \"xz\")"},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"read","dir":"Articles","previous_headings":"Introduction > Download and preprocess","what":"Read","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"","code":"state <- tigris::states(year = 2022) statemain <-   state[!state$STUSPS %in% c(\"AK\", \"HI\", \"PR\", \"VI\", \"GU\", \"MP\", \"AS\"), ] target_states <- statemain$GEOID  # download populated places options(tigris_use_cache = TRUE) popplace <-   lapply(target_states, function(x) {     tigris::places(year = 2022, state = x)   }) popplace <- do.call(rbind, popplace)   # generate circular buffers with 10 km radius popplacep <- sf::st_centroid(popplace, of_largest_polygon = TRUE) %>%   sf::st_transform(\"EPSG:5070\") popplacep2 <- sf::st_centroid(popplace, of_largest_polygon = TRUE) popplaceb <- sf::st_buffer(popplacep, dist = units::set_units(10, \"km\"))"},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"terraclimate","dir":"Articles","previous_headings":"","what":"TerraClimate","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"TerraClimate data provided yearly NetCDF files, contains monthly layers. read data terra package preprocess data extract annual mean sum bands types columns. reproducibility, run code companion package amadeus download terraClimate data. Please note take depending internet speed.","code":"rlang::check_installed(\"amadeus\")  tcli_variables <- c(   \"aet\", \"def\", \"pet\", \"ppt\", \"q\", \"soil\", \"swe\",   \"PDSI\", \"srad\", \"tmax\", \"tmin\", \"vap\", \"vpd\", \"ws\" )  amadeus::download_terraclimate(   variables = tcli_variables,   year = c(2000, 2022),   directory_to_save = \"./input/terraClimate\",   acknowledgement = TRUE,   download = TRUE,   remove_command = TRUE ) # wbd ext_mainland <- c(xmin = -126, xmax = -64, ymin = 22, ymax = 51) ext_mainland <- terra::ext(ext_mainland)  path_tc <- file.path(\"input\", \"terraClimate\") path_tc_files <- list.files(   path = path_tc, pattern = \"*.nc$\",   full.names = TRUE ) path_tc_files #>  [1] \"input/terraClimate/TerraClimate_aet_2000.nc\"  #>  [2] \"input/terraClimate/TerraClimate_aet_2001.nc\" #>  [truncated] #> [321] \"input/terraClimate/TerraClimate_ws_2021.nc\"   #> [322] \"input/terraClimate/TerraClimate_ws_2022.nc\""},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"preprocessing","dir":"Articles","previous_headings":"TerraClimate","what":"Preprocessing","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"Fourteen variables available TerraClimate data. table TerraClimate website. variables can categorized two types: summed averaged. Sum: aet, def, pet, ppt, q, soil, swe. Mean: PDSI, srad, tmax, tmin, vap, vpd, ws. Following rationale, preprocess data summing first seven layers averaging rest layers. code blocks follow “split-apply-combine” strategy. Note terra::tapp aggregates layers attributes time custom indices. \\[!WARNING\\] Stacking raster data may take long time consume large amount memory depending users’ area interest data resolution. Users need consider memory capacity system stacking rasters. 14 data elements 23 years 12 months . demonstrates summary data layers averaged circular buffer polygons 10 kilometers (10,000 meters) radius. leverage multiple cores machine, run future::availableCores() check number cores set number workers future::plan accordingly. Typically, two logical cores physical core modern central processing units. number workers set number physical cores machine optimal performance. example uses future::multicore shares memory across workers. \\[!CAUTION\\] Windows users RStudio users (platforms) able use future::multicore due restriction future package. Please future::multisession instead note option runs slower future::multicore case.","code":"options(future.globals = FALSE) # some bands should be summed bandnames <- c(   \"aet\", \"def\", \"PDSI\", \"pet\", \"ppt\", \"q\", \"soil\", \"srad\",   \"swe\", \"tmax\", \"tmin\", \"vap\", \"vpd\", \"ws\" ) bandnames_sorted <- sort(bandnames)  # single nc file, yearly aggregation by fun value # band for summation bandnames_sum <- c(\"aet\", \"def\", \"pet\", \"ppt\", \"q\", \"soil\", \"swe\")  # band for averaging bandnames_avg <- c(\"PDSI\", \"srad\", \"tmax\", \"tmin\", \"vap\", \"vpd\", \"ws\")  # mean: temporally marginal pixel mean (i.e., monthly -> yearly) # sum: temporally marginal pixel sum (i.e., monthly -> yearly) # Preprocessed data are stored in tictoc::tic(\"sum: 7 layers\") netcdf_read_sum <-   split(bandnames_sum, bandnames_sum) |>   lapply(function(x) {     grep(paste0(\"(\", x, \")\"), path_tc_files, value = TRUE)   }) |>   lapply(function(x) {     terra::tapp(terra::rast(x, win = ext_mainland, snap = \"out\"), index = \"years\", fun = \"sum\")   }) netcdf_read_sum <- Reduce(c, netcdf_read_sum) tictoc::toc() #> sum: 7 layers: 177.974 sec elapsed names(netcdf_read_sum) <- paste0(rep(bandnames_sum, each = 23), \"_\", rep(2000:2022, 7)) netcdf_read_sum #> class       : SpatRaster  #> dimensions  : 696, 1488, 161  (nrow, ncol, nlyr) #> resolution  : 0.04166667, 0.04166667  (x, y) #> extent      : -126, -64, 22, 51  (xmin, xmax, ymin, ymax) #> coord. ref. : +proj=longlat +ellps=WGS84 +no_defs  #> source(s)   : memory #> names       : aet_2000,  aet_2001,  aet_2002,  aet_2003, ...  #> min values  :     22.9,      27.3,        11,      30.8, ...  #> max values  :   1270.9,    1366.6,      1399,    1411.1, ...  #> time (years):   2000 to 2022 # tictoc::tic(\"mean: 7 layers\") # netcdf_read_mean <- #   split(bandnames_avg, bandnames_avg) |> #   lapply(function(x) { #     grep(paste0(\"(\", x, \")\"), path_tc_files, value = TRUE) #   }) |> #   lapply(function(x) { #     terra::tapp(terra::rast(x, win = ext_mainland, snap = \"out\"), index = \"years\", fun = \"mean\") #   }) |> #   Reduce(f = c, x = _) # tictoc::toc()  # names(netcdf_read_mean) <- #   sprintf(\"%s_%d\", rep(bandnames_avg, each = 23), rep(2000:2022, 7)) # netcdf_read_mean tic(\"multi threads (grid)\") future::plan(future::multicore, workers = 8L) grid_init <-   chopin::par_pad_grid(     popplacep2,     mode = \"grid\",     padding = 1e4,     nx = 4L,     ny = 2L   ) multi_grid <-   chopin::par_grid(     grids = grid_init,     fun_dist = extract_at,     y = popplacep2,     x = netcdf_read_sum,     id = \"GEOID\",     func = \"mean\",     radius = 1e4   ) toc() #> multi threads (grid): 16.668 sec elapsed system.time(   multi <-     grep(       paste0(\"(\", paste(bandnames_sum, collapse = \"|\"), \")\"),       path_tc_files,       value = TRUE     ) %>%     chopin::par_multirasters(       filenames = .,       fun_dist = extract_at,       y = popplacep2,       x = rast(), # ignored       id = \"GEOID\",       func = \"mean\",       radius = 1e4     ) ) #>     user   system  elapsed  #> 5377.495  231.654  762.147 future::plan(future::sequential)   # single thread tic(\"single thread\") single <-   exactextractr::exact_extract(     netcdf_read_sum,     sf::st_as_sf(popplaceb),     fun = \"mean\",     stack_apply = TRUE,     force_df = TRUE,     append_cols = c(\"GEOID\"),     progress = FALSE   ) toc() #> single thread: 21.161 sec elapsed"},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"prism-dataset","dir":"Articles","previous_headings":"","what":"PRISM dataset","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"PRISM data provided monthly 30-year normal BIL files. Assuming user wants summarize 30-year normal precipitation 10 kilometers circular buffers geogrpahic centroids US Census Places (p.26), demonstrate extraction process chopin package.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"download-1","dir":"Articles","previous_headings":"PRISM dataset > Download and preprocess","what":"Download","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"","code":"# populated places # mainland states state <- tigris::states(year = 2022) statemain <-   state[!state$STUSPS %in% c(\"AK\", \"HI\", \"PR\", \"VI\", \"GU\", \"MP\", \"AS\"), ] target_states <- statemain$GEOID  popplace <-   lapply(target_states, function(x) tigris::places(x, year = 2022)) %>%   do.call(rbind, .) saveRDS(popplace, \"./input/populated_place_2022.rds\", compress = \"xz\")"},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"read-1","dir":"Articles","previous_headings":"PRISM dataset > Download and preprocess","what":"Read","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"\\[!IMPORTANT\\] chopin::par_pad_grid works best point datasets since grid clip input features parallelized. Polygon inputs result duplicate values output lead take longer complete.","code":"bils <- list.files(\"input\", \"bil$\", recursive = TRUE, full.names = TRUE) bilssds <- terra::rast(bils[-13]) popplace2 <- sf::st_transform(popplace, crs = terra::crs(bilssds)) popplaceb2 <- sf::st_transform(popplaceb, crs = terra::crs(bilssds))"},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"grid-parallelization","dir":"Articles","previous_headings":"PRISM dataset","what":"Grid parallelization","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"vein TerraClimate data, use chopin package parallelize extraction process grid strategy.","code":"exgrid <-   chopin::par_pad_grid(     popplacep2,     mode = \"grid\",     padding = 1e4,     nx = 4L,     ny = 2L   )   future::plan(future::multicore, workers = 8L)  system.time(   exmulti <-     chopin::par_grid(       exgrid,       fun_dist = extract_at,       y = popplacep2,       x = bilssds,       radius = units::set_units(1e4, \"meter\"),       id = \"GEOID\",       func = \"mean\"     ) ) #> Your input function was successfully run at CGRIDID: 1 #> Your input function was successfully run at CGRIDID: 2 #> Your input function was successfully run at CGRIDID: 3 #> Your input function was successfully run at CGRIDID: 4 #> Your input function was successfully run at CGRIDID: 5 #> Your input function was successfully run at CGRIDID: 6 #> Your input function was successfully run at CGRIDID: 7 #> Your input function was successfully run at CGRIDID: 8 #>    user  system elapsed  #>  33.090  13.254  14.571 system.time(   exsingle <-     exactextractr::exact_extract(       bilssds,       popplaceb2,       fun = \"mean\",       stack_apply = TRUE,       force_df = TRUE,       append_cols = \"GEOID\",       max_cells_in_memory = 2.14e9,       progress = FALSE     ) ) #>    user  system elapsed  #>  19.347   1.927  21.716 future::plan(future::sequential)"},{"path":[]},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"larger-buffer-sizes","dir":"Articles","previous_headings":"Scaled up examples","what":"Larger buffer sizes","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"Examples showed difference parallelized single-threaded extraction process significant. increase buffer size 50 kilometers compare performance parallelized single-threaded extraction process. \\[!NOTE\\] example used strings raster file paths surf argument chopin::extract_at_buffer. terra::rast multiple file paths return SpatRaster multiple layers rasters extent resolution.","code":"# make buffers popplaceb5 <- sf::st_buffer(popplacep, dist = units::set_units(50, \"km\")) %>%   sf::st_transform(terra::crs(bilssds))  system.time(   exsingle5 <-     exactextractr::exact_extract(       bilssds,       popplaceb5,       fun = \"mean\",       stack_apply = TRUE,       force_df = TRUE,       append_cols = \"GEOID\",       max_cells_in_memory = 2.14e9,       progress = FALSE     ) ) #>    user  system elapsed  #> 140.373   2.302 144.552 exgrid5k <-   chopin::par_pad_grid(     popplacep2,     mode = \"grid\",     padding = 5e4,     nx = 4L,     ny = 2L   )   future::plan(future::multicore, workers = 8L)  system.time(   exmulti5k <-     chopin::par_grid(       exgrid5k,       fun_dist = extract_at,       y = popplacep2,       x = bilssds,       radius = 5e4,       id = \"GEOID\",       func = \"mean\"     ) ) #> Your input function was successfully run at CGRIDID: 1 #> Your input function was successfully run at CGRIDID: 2 #> Your input function was successfully run at CGRIDID: 3 #> Your input function was successfully run at CGRIDID: 4 #> Your input function was successfully run at CGRIDID: 5 #> Your input function was successfully run at CGRIDID: 6 #> Your input function was successfully run at CGRIDID: 7 #> Your input function was successfully run at CGRIDID: 8 #>    user  system elapsed  #> 152.344  11.003  60.409 future::plan(future::sequential)"},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"larger-number-of-features","dir":"Articles","previous_headings":"Scaled up examples","what":"Larger number of features","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"example uses 1,204,934 1-km grid points southeastern United States summarize seven layers TerraClimate.","code":"## generate 1km grid points in the southeastern US States stt <- tigris::states(year = 2020) targ_states <- c(\"NC\", \"SC\", \"GA\", \"FL\", \"AL\", \"MS\", \"TN\", \"LA\", \"AR\") stt_targ <- stt[stt$STUSPS %in% targ_states, ] stt_t <- sf::st_transform(stt_targ, \"EPSG:5070\") stt_g <- sf::st_sample(stt_t, type = \"regular\", 1204934) stt_g <- sf::st_as_sf(stt_g) sf::st_geometry(stt_g) <- \"geometry\" stt_g$pid <- seq(1, nrow(stt_g)) stt_gb <- sf::st_buffer(stt_g, units::set_units(10, \"km\"))  tic() single_2m <-   exactextractr::exact_extract(     netcdf_read_sum,     stt_gb,     fun = \"mean\",     stack_apply = TRUE,     force_df = TRUE,     max_cells_in_memory = 2.14e9,     progress = FALSE   ) toc() #> 855.908 sec elapsed stt_gbg <-   chopin::par_pad_grid(     stt_g,     mode = \"grid\",     padding = 5e3,     nx = 5L,     ny = 5L   )   future::plan(future::multicore, workers = 8L) system.time(   stt5k <-     chopin::par_grid(       stt_gbg,       fun_dist = extract_at,       y = stt_g,       x = netcdf_read_sum,       id = \"pid\",       radius = 1e4,       func = \"mean\",       max_cells = 2e7     ) ) #>   user  system elapsed  #>  6.745   4.102 434.041 future::plan(future::sequential)"},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"finely-resolved-vector","dir":"Articles","previous_headings":"Scaled up examples","what":"Finely resolved vector","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"Using PRISM data, example summarizes mean values data element census block groups.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"download-2","dir":"Articles","previous_headings":"Scaled up examples > Finely resolved vector","what":"Download","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"","code":"# set state=NULL and cb=TRUE will download the block groups for the entire US bg <- tigris::block_groups(state = NULL, cb = TRUE, year = 2020) sf::write_sf(bg, file.path(\"input\", \"Blockgroups_2020.gpkg\"))"},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"extract","dir":"Articles","previous_headings":"Scaled up examples > Finely resolved vector","what":"Extract","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"","code":"## extract prism by par_hierarchy bgsf <- sf::st_read(\"input/Blockgroups_2020.gpkg\") #> Reading layer `Blockgroups_2020' from data source  #>   `/ddn/gs1/home/songi2/projects/chopin/input/Blockgroups_2020.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 242298 features and 11 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -179.1467 ymin: -14.5487 xmax: 179.7785 ymax: 71.38782 #> Geodetic CRS:  NAD83 bgsf_main <- bgsf %>%   dplyr::filter(!STATEFP %in% c(\"02\", \"15\", \"72\", \"66\", \"78\", \"60\", \"69\"))  ## extract prism at bg system.time(   exsingle <-     exactextractr::exact_extract(       bilssds,       bgsf_main,       fun = \"mean\",       stack_apply = TRUE,       force_df = TRUE,       append_cols = \"GEOID\",       max_cells_in_memory = 2.14e9,       progress = FALSE     ) ) #>    user  system elapsed  #>  60.387   2.059  64.147 nmain <- c(\"AS\", \"AK\", \"HI\", \"PR\", \"VI\", \"GU\", \"MP\") stt_nmain <- stt[!stt$STUSPS %in% nmain, ]   future::plan(future.mirai::mirai_multisession, workers = 20L) system.time(   exhierarchy <-     chopin::par_hierarchy(       bgsf_main,       regions_id = \"STATEFP\",       fun_dist = extract_at,       y = bgsf_main,       x = bilssds,       id = \"GEOID\"     ) ) #>    user  system elapsed  #>   2.205   0.558 158.905 future::plan(future::sequential)"},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"finely-resolved-raster","dir":"Articles","previous_headings":"Scaled up examples","what":"Finely resolved raster","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"demonstrate extraction process CropScape dataset resolution 30 meters. case, use frac option exact_extract tabulates fraction area cell category covered polygon accounting partial coverage polygon segments raster cells. balancing computation time, split block groups nine subsets parallelize. Note mode = \"grid_quantile\" used par_pad_grid balance number block groups per grid. input argument par_pad_grid polygons, polygons duplicate rows output data.frame since block groups overlapping grid selected.","code":"cdl <- terra::rast(\"input/2022_cdls/2022_30m_cdls.tif\")  system.time(   bgsf_cdl_single <-     exactextractr::exact_extract(       cdl,       bgsf_main,       fun = \"frac\",       stack_apply = TRUE,       force_df = TRUE,       append_cols = \"GEOID\",       max_cells_in_memory = 2.14e9,       progress = FALSE     ) ) #>     user   system  elapsed  #> 1013.411   44.322 1369.053 cdl <- terra::rast(\"input/2022_cdls/2022_30m_cdls.tif\") bgsf <- sf::st_read(\"input/Blockgroups_2020.gpkg\") bgsf_main <- bgsf %>%   dplyr::filter(!STATEFP %in% c(\"02\", \"15\", \"72\", \"66\", \"78\", \"60\", \"69\"))   # balancing the number of features assigned per workers # by splitting block groups by splitting centroids bgsf_9grids_plain <- bgsf_main %>%   chopin::par_pad_grid(     mode = \"grid\",     nx = 3L, ny = 3L, padding = 1e4   ) bgsf_9grids <- bgsf_main %>%   chopin::par_pad_grid(     mode = \"grid_quantile\",     padding = 1e4,     quantiles = chopin::par_def_q(3L)   )   future::plan(future.mirai::mirai_multisession, workers = 9L) # Note that bgsf_9grids were converted to sf # for exporting the objects to the parallel workers system.time(   bgsf_cdl_par <-     chopin::par_grid(       lapply(bgsf_9grids, sf::st_as_sf),       fun_dist = extract_at,       y = bgsf_main,       x = cdl,       id = \"GEOID\",       func = \"frac\",       max_cells = 2e7     ) ) #> Your input function was successfully run at CGRIDID: 1 #> Your input function was successfully run at CGRIDID: 2 #> Your input function was successfully run at CGRIDID: 3 #> Your input function was successfully run at CGRIDID: 4 #> Your input function was successfully run at CGRIDID: 5 #> Your input function was successfully run at CGRIDID: 6 #> Your input function was successfully run at CGRIDID: 7 #> Your input function was successfully run at CGRIDID: 8 #> Your input function was successfully run at CGRIDID: 9 #>   user  system elapsed  #>  6.632   1.821 347.638"},{"path":"https://docs.ropensci.org/chopin/articles/v04_climate_examples.html","id":"see-also","dir":"Articles","previous_headings":"Scaled up examples","what":"See also","title":"Extracting Weather/Climate Geospatial Data with `chopin`","text":"Garnett, R. (2023). Geospatial distributed processing furrr Dyba, K. (n.d.). Parallel raster processing stars","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v05_targets.html","id":"objective","dir":"Articles","previous_headings":"","what":"Objective","title":"targets and grid objects","text":"targets powerful workflow management reproducibility. chopin grid partitioning way parallelize repeated tasks across unit grids applying patterns. vignette demonstrates use targets chopin together.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v05_targets.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"targets and grid objects","text":"Despite targets referenced DESCRIPTION file, required install targets package run code vignette.","code":"rlang::check_installed(\"targets\")"},{"path":"https://docs.ropensci.org/chopin/articles/v05_targets.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"targets and grid objects","text":"par_pad_grid() par_pad_balanced() functions argument return_wkt return grid partition well-known text (WKT) format characters. format exported parallel workers regardless parallel backend future::multisession mirai::daemons, interoperate externalpnt objects C++ functions. Using WKT character objects, can easily convert sf terra objects inside function running parallel worker use targets workflow standard branching/patterning interface map(), cross(), others. example generate grid partition North Carolina state demonstrate use grid partition targets workflow.","code":""},{"path":"https://docs.ropensci.org/chopin/articles/v05_targets.html","id":"random-points-in-nc","dir":"Articles","previous_headings":"Example","what":"Random points in NC","title":"targets and grid objects","text":"demonstration par_pad_grid(), use moderately clustered point locations generated inside counties North Carolina.","code":"library(chopin) library(sf) library(spatstat.random)  sf::sf_use_s2(FALSE) set.seed(202404) ncpoly <- system.file(\"shape/nc.shp\", package = \"sf\") ncsf <- sf::read_sf(ncpoly) ncsf <- sf::st_transform(ncsf, \"EPSG:5070\") plot(sf::st_geometry(ncsf)) ncpoints <-   sf::st_sample(     x = ncsf,     type = \"Thomas\",     mu = 20,     scale = 1e4,     kappa = 1.25e-9   ) ncpoints <- sf::st_as_sf(ncpoints) ncpoints <- sf::st_set_crs(ncpoints, \"EPSG:5070\") ncpoints$pid <- sprintf(\"PID-%05d\", seq(1, nrow(ncpoints))) plot(sf::st_geometry(ncpoints))"},{"path":"https://docs.ropensci.org/chopin/articles/v05_targets.html","id":"grid-partition-of-nc","dir":"Articles","previous_headings":"Example","what":"Grid partition of NC","title":"targets and grid objects","text":"Since sf objects exportable parallel workers, can also consider part targets workflow.","code":"ncgrid_sf <-   par_pad_grid(     input = ncpoints,     mode = \"grid\",     nx = 6L,     ny = 3L,     padding = 1e4L,     return_wkt = FALSE   )  ncgrid_sf$original ## Simple feature collection with 18 features and 1 field ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 1057207 ymin: 1355820 xmax: 1830518 ymax: 1676480 ## Projected CRS: NAD83 / Conus Albers ## First 10 features: ##                          geometry CGRIDID ## 1  POLYGON ((1057207 1355820, ...       1 ## 2  POLYGON ((1186093 1355820, ...       2 ## 3  POLYGON ((1314978 1355820, ...       3 ## 4  POLYGON ((1443863 1355820, ...       4 ## 5  POLYGON ((1572748 1355820, ...       5 ## 6  POLYGON ((1701633 1355820, ...       6 ## 7  POLYGON ((1057207 1462707, ...       7 ## 8  POLYGON ((1186093 1462707, ...       8 ## 9  POLYGON ((1314978 1462707, ...       9 ## 10 POLYGON ((1443863 1462707, ...      10 ncgrid_sf$padded ## Simple feature collection with 18 features and 1 field ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 1047207 ymin: 1345820 xmax: 1840518 ymax: 1686480 ## Projected CRS: NAD83 / Conus Albers ## First 10 features: ##    CGRIDID                       geometry ## 1        1 POLYGON ((1047207 1345820, ... ## 2        2 POLYGON ((1176093 1345820, ... ## 3        3 POLYGON ((1304978 1345820, ... ## 4        4 POLYGON ((1433863 1345820, ... ## 5        5 POLYGON ((1562748 1345820, ... ## 6        6 POLYGON ((1691633 1345820, ... ## 7        7 POLYGON ((1047207 1452707, ... ## 8        8 POLYGON ((1176093 1452707, ... ## 9        9 POLYGON ((1304978 1452707, ... ## 10      10 POLYGON ((1433863 1452707, ... ncgrid_wkt <-   par_pad_grid(     input = ncpoints,     mode = \"grid\",     nx = 6L,     ny = 3L,     padding = 1e4L,     return_wkt = TRUE   )  ncgrid_wkt$original ##  [1] \"POLYGON ((1057207 1355820, 1186093 1355820, 1186093 1462707, 1057207 1462707, 1057207 1355820))\" ##  [2] \"POLYGON ((1186093 1355820, 1314978 1355820, 1314978 1462707, 1186093 1462707, 1186093 1355820))\" ##  [3] \"POLYGON ((1314978 1355820, 1443863 1355820, 1443863 1462707, 1314978 1462707, 1314978 1355820))\" ##  [4] \"POLYGON ((1443863 1355820, 1572748 1355820, 1572748 1462707, 1443863 1462707, 1443863 1355820))\" ##  [5] \"POLYGON ((1572748 1355820, 1701633 1355820, 1701633 1462707, 1572748 1462707, 1572748 1355820))\" ##  [6] \"POLYGON ((1701633 1355820, 1830518 1355820, 1830518 1462707, 1701633 1462707, 1701633 1355820))\" ##  [7] \"POLYGON ((1057207 1462707, 1186093 1462707, 1186093 1569593, 1057207 1569593, 1057207 1462707))\" ##  [8] \"POLYGON ((1186093 1462707, 1314978 1462707, 1314978 1569593, 1186093 1569593, 1186093 1462707))\" ##  [9] \"POLYGON ((1314978 1462707, 1443863 1462707, 1443863 1569593, 1314978 1569593, 1314978 1462707))\" ## [10] \"POLYGON ((1443863 1462707, 1572748 1462707, 1572748 1569593, 1443863 1569593, 1443863 1462707))\" ## [11] \"POLYGON ((1572748 1462707, 1701633 1462707, 1701633 1569593, 1572748 1569593, 1572748 1462707))\" ## [12] \"POLYGON ((1701633 1462707, 1830518 1462707, 1830518 1569593, 1701633 1569593, 1701633 1462707))\" ## [13] \"POLYGON ((1057207 1569593, 1186093 1569593, 1186093 1676480, 1057207 1676480, 1057207 1569593))\" ## [14] \"POLYGON ((1186093 1569593, 1314978 1569593, 1314978 1676480, 1186093 1676480, 1186093 1569593))\" ## [15] \"POLYGON ((1314978 1569593, 1443863 1569593, 1443863 1676480, 1314978 1676480, 1314978 1569593))\" ## [16] \"POLYGON ((1443863 1569593, 1572748 1569593, 1572748 1676480, 1443863 1676480, 1443863 1569593))\" ## [17] \"POLYGON ((1572748 1569593, 1701633 1569593, 1701633 1676480, 1572748 1676480, 1572748 1569593))\" ## [18] \"POLYGON ((1701633 1569593, 1830518 1569593, 1830518 1676480, 1701633 1676480, 1701633 1569593))\" ncgrid_wkt$padded ##  [1] \"POLYGON ((1047207 1345820, 1047207 1472707, 1196093 1472707, 1196093 1345820, 1047207 1345820))\" ##  [2] \"POLYGON ((1176093 1345820, 1176093 1472707, 1324978 1472707, 1324978 1345820, 1176093 1345820))\" ##  [3] \"POLYGON ((1304978 1345820, 1304978 1472707, 1453863 1472707, 1453863 1345820, 1304978 1345820))\" ##  [4] \"POLYGON ((1433863 1345820, 1433863 1472707, 1582748 1472707, 1582748 1345820, 1433863 1345820))\" ##  [5] \"POLYGON ((1562748 1345820, 1562748 1472707, 1711633 1472707, 1711633 1345820, 1562748 1345820))\" ##  [6] \"POLYGON ((1691633 1345820, 1691633 1472707, 1840518 1472707, 1840518 1345820, 1691633 1345820))\" ##  [7] \"POLYGON ((1047207 1452707, 1047207 1579593, 1196093 1579593, 1196093 1452707, 1047207 1452707))\" ##  [8] \"POLYGON ((1176093 1452707, 1176093 1579593, 1324978 1579593, 1324978 1452707, 1176093 1452707))\" ##  [9] \"POLYGON ((1304978 1452707, 1304978 1579593, 1453863 1579593, 1453863 1452707, 1304978 1452707))\" ## [10] \"POLYGON ((1433863 1452707, 1433863 1579593, 1582748 1579593, 1582748 1452707, 1433863 1452707))\" ## [11] \"POLYGON ((1562748 1452707, 1562748 1579593, 1711633 1579593, 1711633 1452707, 1562748 1452707))\" ## [12] \"POLYGON ((1691633 1452707, 1691633 1579593, 1840518 1579593, 1840518 1452707, 1691633 1452707))\" ## [13] \"POLYGON ((1047207 1559593, 1047207 1686480, 1196093 1686480, 1196093 1559593, 1047207 1559593))\" ## [14] \"POLYGON ((1176093 1559593, 1176093 1686480, 1324978 1686480, 1324978 1559593, 1176093 1559593))\" ## [15] \"POLYGON ((1304978 1559593, 1304978 1686480, 1453863 1686480, 1453863 1559593, 1304978 1559593))\" ## [16] \"POLYGON ((1433863 1559593, 1433863 1686480, 1582748 1686480, 1582748 1559593, 1433863 1559593))\" ## [17] \"POLYGON ((1562748 1559593, 1562748 1686480, 1711633 1686480, 1711633 1559593, 1562748 1559593))\" ## [18] \"POLYGON ((1691633 1559593, 1691633 1686480, 1840518 1686480, 1840518 1559593, 1691633 1559593))\""},{"path":"https://docs.ropensci.org/chopin/articles/v05_targets.html","id":"targets-workflow","dir":"Articles","previous_headings":"Example","what":"Targets workflow","title":"targets and grid objects","text":"Assume design function calc_something() calculates something grid partition. can use grid partition input function. sf object centered workflow, can use sf functions interact exported grid partition objects. Let’s consider binary spatial operation x y involved. x dataset variable calculated whereas y raster file path extract values. Please note SpatRaster objects exported parallel workers . read object parallel workers. branch across grid partition, function unit grid handle subsetting x narrow calculation scope grid. Therefore, synopsis function look like : map(unit_grid, pad_grid) pattern argument tar_target() . sf object inherits data.frame class. align object targets branching, clear convert object list object pattern across grid partition. par_split_list chopin . WKT format used, function modified restore grid partition sf objects. function modified follows: tar_target can use list object function calc_something branch . workable example tar_target proper _targets.R file follows: target result list data.frames contain calculation results.","code":"calc_something <- function(x, y, unit_grid, pad_grid, ...) {   # 0. restore unit_grid and pad_grid to sf objects if they are in WKT format   # 1-1. make x subset using intersect logic between x and unit_grid   # 1-2. read y subset using intersect logic between y and pad_grid   # 2. make buffer of x   # 3. do actual calculation (use ... wisely to pass additional arguments)   # 4. return the result } calc_something <- function(x, y, unit_grid, pad_grid, ...) {   # 1-1. make x subset using intersect logic between x and unit_grid   x <- x[unit_grid, ]   # 1-2. read y subset using intersect logic between y and pad_grid   yext <- terra::ext(sf::st_bbox(pad_grid))   yras <- terra::rast(y, win = yext)   # 2. make buffer of x   xbuffer <- sf::st_buffer(x, units::set_units(10, \"km\"))   # 3. do actual calculation (use ... wisely to pass additional arguments)   xycalc <- exactextractr::exact_extract(     yras,     xbuffer,     force_df = TRUE,     fun = \"mean\",     append_cols = \"pid\", # assume that pid is a unique identifier     progress = FALSE   )   # 4. return the result   return(xycalc) } ncgrid_sflist <-   par_split_list(ncgrid_sf) calc_something <- function(x, y, unit_grid, pad_grid, ...) {   # 0. restore unit_grid and pad_grid to sf objects if they are in WKT format   unit_grid <- sf::st_as_sf(wkt = unit_grid)   pad_grid <- sf::st_as_sf(wkt = pad_grid)   # 1-1. make x subset using intersect logic between x and unit_grid   x <- x[unit_grid, ]   # 1-2. read y subset using intersect logic between y and pad_grid   yext <- terra::ext(sf::st_bbox(pad_grid))   yras <- terra::rast(y, win = yext)   # 2. make buffer of x   xbuffer <- sf::st_buffer(x, units::set_units(10, \"km\"))   # 3. do actual calculation (use ... wisely to pass additional arguments)   xycalc <- exactextractr::exact_extract(     yras,     xbuffer,     fun = \"mean\",     force_df = TRUE,     append_cols = \"pid\", # assume that pid is a unique identifier     progress = FALSE   )   # 4. return the result   return(xycalc) } ncgrid_wktlist <-   par_split_list(ncgrid_wkt) list(   tar_target(     name = points,     command = sf::st_read(\"path_to_points.format\")   ),   tar_target(     name = raster,     command = \"path_to_raster.format\",     format = \"file\"   ),   tar_target(     name = chopingrid,     command = par_pad_grid(points, input = points, nx = 6L, ny = 3L, padding = 1e4L, return_wkt = FALSE)   ),   tar_target(     name = chopingrid_split,     command = mapply(       function(listorig, row) {         list(listorig$original[row, ], listorig$padded[row, ])       },       chopingrid, seq_len(nrow(chopingrid$original)),       SIMPLIFY = FALSE     ),     iteration = \"list\"   ),   tar_target(     name = result,     command =     calc_something(       points, raster,       chopingrid_split[[1]], chopingrid_split[[2]]     ),     pattern = map(chopingrid_split),     iteration = \"list\"   ) )"},{"path":"https://docs.ropensci.org/chopin/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Insang Song. Author, maintainer. Kyle Messier. Author, contributor. Alec L. Robitaille. Reviewer.           Alec reviewed package version 0.6.3 rOpenSci, see <https://github.com/ropensci/software-review/issues/638> Eric R. Scott. Reviewer.           Eric reviewed package version 0.6.3 rOpenSci, see <https://github.com/ropensci/software-review/issues/638>","code":""},{"path":"https://docs.ropensci.org/chopin/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Song , Messier K (2025). chopin: Computation Spatial Data Hierarchical Objective Partitioning Inputs Parallel Processing. R package version 0.9.0, https://github.com/ropensci/chopin, https://docs.ropensci.org/chopin.","code":"@Manual{,   title = {chopin: Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing},   author = {Insang Song and Kyle Messier},   year = {2025},   note = {R package version 0.9.0, https://github.com/ropensci/chopin},   url = {https://docs.ropensci.org/chopin}, }"},{"path":[]},{"path":"https://docs.ropensci.org/chopin/index.html","id":"objective","dir":"","previous_headings":"","what":"Objective","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"package automates parallelization spatial operations chopin functions well sf/terra functions. GDAL-compatible files database tables, chopin functions help calculate spatial variables vector raster data external software requirements. need perform geospatial operations large datasets may find package useful accelerate covariate calculation process analysis modeling may find main functions useful. assume users basic knowledge geographic information system data models, coordinate systems transformations, spatial operations, raster-vector overlay.","code":""},{"path":"https://docs.ropensci.org/chopin/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"chopin encapsulates parallel processing spatial computation three steps. First, users define parallelization strategy, one many supported future future.mirai packages. Users always need register parallel workers future running par_*() functions introduced . Second, users choose proper data parallelization configuration creating grid partition processing extent, defining field name values hierarchically coded, entering multiple raster file paths par_multirasters(). Finally, users run par_*() function configurations set compute spatial variables input data parallel: par_grid: parallelize artificial grid polygons generated maximum extent inputs. par_pad_grid used generate grid polygons running function. par_hierarchy: parallelize hierarchy coded identifier fields (example, census blocks county US) par_multirasters: parallelize multiple raster files par_* functions introduced mirai version suffix _mirai function names: par_grid_mirai, par_hierarchy_mirai, par_multirasters. functions work properly creating daemons mirai::daemons. grid partitioning, entire study area divided partly overlapped grids. suggest two flowcharts help function use parallel processing . upper flowchart raster-oriented lower vector-oriented. supplementary . user follows raster-oriented one, might visit vector-oriented flowchart end raster-oriented flowchart. Processing functions accept terra/sf classes spatial data. Raster-vector overlay done exactextractr. Three helper functions encapsulate multiple geospatial data calculation steps multiple CPU threads. extract_at: extract raster values point buffers polygons without kernel weights summarize_sedc: calculate sums exponentially decaying contributions summarize_aw: area-weighted covariates based target reference polygons","code":"future::plan(future.mirai::mirai_multisession, workers = 4L) # future::multisession, future::cluster are available, # See future.batchtools and future.callr for other options # the number of workers are up to users' choice mirai::daemons(4L, dispatcher = \"process\")"},{"path":"https://docs.ropensci.org/chopin/index.html","id":"function-selection-guide","dir":"","previous_headings":"Overview","what":"Function selection guide","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"provide two flowcharts help users choose right function parallel processing. raster-oriented flowchart users want start raster data, vector-oriented flowchart users large vector data. raster-oriented selection, suggest four factors consider: Number raster files: multiple files, par_multirasters recommended. multiple rasters share extent resolution, consider stacking rasters multilayer SpatRaster object calling terra::rast(filenames). Raster resolution: suggest 100 meters threshold. Rasters resolution coarser 100 meters layers better direct call exactextractr::exact_extract(). Raster extent: Using SpatRaster exactextractr::exact_extract() often minimally affected raster extent. Memory size: max_cells_in_memory argument value exactextractr::exact_extract(), raster resolution, number layers SpatRaster multiplicatively related memory usage.  vector-oriented selection, suggest three factors consider: Number features: number features 100,000, consider using par_grid par_hierarchy split data smaller chunks. Hierarchical structure: data hierarchical structure, consider using par_hierarchy parallelize operation. Data grouping: data needs grouped similar sizes, consider using par_pad_balanced par_pad_grid mode =     \"grid_quantile\".","code":""},{"path":"https://docs.ropensci.org/chopin/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"chopin can installed using remotes::install_github (also possible pak::pak devtools::install_github). can also set repos install.packages() ROpenSci repository:","code":"rlang::check_installed(\"remotes\") remotes::install_github(\"ropensci/chopin\") install.packages(\"chopin\", repos = \"https://ropensci.r-universe.dev\")"},{"path":"https://docs.ropensci.org/chopin/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"Examples navigate par_grid, par_hierarchy, par_multirasters functions chopin parallelize geospatial operations.","code":"# check and install packages to run examples pkgs <- c(\"chopin\", \"dplyr\", \"sf\", \"terra\", \"future\", \"future.mirai\", \"mirai\") # install packages if anything is unavailable rlang::check_installed(pkgs)  library(chopin) library(dplyr) #>  #> Attaching package: 'dplyr' #> The following objects are masked from 'package:stats': #>  #>     filter, lag #> The following objects are masked from 'package:base': #>  #>     intersect, setdiff, setequal, union library(sf) #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.3.1; sf_use_s2() is TRUE library(terra) #> terra 1.7.83 library(future) library(future.mirai) library(mirai)  # disable spherical geometries sf::sf_use_s2(FALSE) #> Spherical geometry (s2) switched off  # parallelization-safe random number generator set.seed(2024, kind = \"L'Ecuyer-CMRG\")"},{"path":"https://docs.ropensci.org/chopin/index.html","id":"par_grid-parallelize-over-artificial-grid-polygons","dir":"","previous_headings":"Examples","what":"par_grid: parallelize over artificial grid polygons","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"Please refer small example extracting mean altitude values circular point buffers census tracts North Carolina. running code chunks , set cloned chopin repository working directory setwd()","code":"ncpoly <- system.file(\"shape/nc.shp\", package = \"sf\") ncsf <- sf::read_sf(ncpoly) ncsf <- sf::st_transform(ncsf, \"EPSG:5070\") plot(sf::st_geometry(ncsf))"},{"path":"https://docs.ropensci.org/chopin/index.html","id":"generate-random-points-in-nc","dir":"","previous_headings":"Examples > par_grid: parallelize over artificial grid polygons","what":"Generate random points in NC","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"Ten thousands random point locations generated inside counties North Carolina.","code":"ncpoints <- sf::st_sample(ncsf, 1e4) ncpoints <- sf::st_as_sf(ncpoints) ncpoints$pid <- sprintf(\"PID-%05d\", seq(1, 1e4)) plot(sf::st_geometry(ncpoints))"},{"path":"https://docs.ropensci.org/chopin/index.html","id":"target-raster-dataset-shuttle-radar-topography-mission","dir":"","previous_headings":"Examples > par_grid: parallelize over artificial grid polygons","what":"Target raster dataset: Shuttle Radar Topography Mission","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"use elevation dataset moderate spatial resolution (approximately 400 meters 0.25 miles).","code":"# data preparation wdir <- system.file(\"extdata\", package = \"chopin\") srtm <- file.path(wdir, \"nc_srtm15_otm.tif\")  # terra SpatRaster objects are wrapped when exported to rds file srtm_ras <- terra::rast(srtm) terra::crs(srtm_ras) <- \"EPSG:5070\" srtm_ras #> class       : SpatRaster  #> dimensions  : 1534, 2281, 1  (nrow, ncol, nlyr) #> resolution  : 391.5026, 391.5026  (x, y) #> extent      : 1012872, 1905890, 1219961, 1820526  (xmin, xmax, ymin, ymax) #> coord. ref. : NAD83 / Conus Albers (EPSG:5070)  #> source      : nc_srtm15_otm.tif  #> name        :    srtm15  #> min value   : -3589.291  #> max value   :  1946.400 terra::plot(srtm_ras) # ncpoints_tr <- terra::vect(ncpoints) system.time(   ncpoints_srtm <-     chopin::extract_at(       x = srtm,       y = ncpoints,       id = \"pid\",       mode = \"buffer\",       radius = 1e4L  # 10,000 meters (10 km)     ) ) #> Input is a character. Attempt to read it with terra::rast... #>    user  system elapsed  #>   5.458   0.088   5.580"},{"path":"https://docs.ropensci.org/chopin/index.html","id":"generate-regular-grid-computational-regions","dir":"","previous_headings":"Examples > par_grid: parallelize over artificial grid polygons","what":"Generate regular grid computational regions","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"chopin::par_pad_grid() takes spatial dataset generate regular grid polygons nx ny arguments padding. Users overlapping (degree radius) non-overlapping grids, utilized split locations target datasets sub-datasets efficient processing. compregions list object two elements named original (non-overlapping grid polygons) padded (overlapping padding). figures illustrate grid polygons without overlaps.","code":"compregions <-   chopin::par_pad_grid(     ncpoints,     mode = \"grid\",     nx = 2L,     ny = 2L,     padding = 1e4L   ) #> Switch sf class to terra... #> Switch terra class to sf... names(compregions) #> [1] \"original\" \"padded\"  oldpar <- par() par(mfrow = c(2, 1)) terra::plot(   terra::vect(compregions$original),   main = \"Original grids\" ) terra::plot(   terra::vect(compregions$padded),   main = \"Padded grids\" )"},{"path":"https://docs.ropensci.org/chopin/index.html","id":"parallel-processing","dir":"","previous_headings":"Examples > par_grid: parallelize over artificial grid polygons","what":"Parallel processing","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"Using grid polygons, distribute task averaging elevations 10,000 circular buffer polygons, generated random locations, 10 kilometers radius chopin::par_grid(). Users always need register multiple CPU threads (logical cores) parallelization. chopin::par_*() functions flexible terms supporting generic spatial operations sf terra, especially two datasets involved. Users can inject generic functions’ arguments (parameters) writing ellipsis (...) arguments, demonstrated :   workflow operates mirai dispatchers.","code":"future::plan(future.mirai::mirai_multisession, workers = 4L)  system.time(   ncpoints_srtm_mthr <-     par_grid(       grids = compregions,       fun_dist = extract_at,       x = srtm,       y = ncpoints,       id = \"pid\",       radius = 1e4L,       .standalone = FALSE     ) ) #> ℹ Input is not a character. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Task at CGRIDID: 1 is successfully dispatched. #>  #> Input is a character. Attempt to read it with terra::rast... #> ℹ Task at CGRIDID: 2 is successfully dispatched. #>  #> Input is a character. Attempt to read it with terra::rast... #> ℹ Task at CGRIDID: 3 is successfully dispatched. #>  #> Input is a character. Attempt to read it with terra::rast... #> ℹ Task at CGRIDID: 4 is successfully dispatched. #>    user  system elapsed  #>   0.336   0.045   7.788  ncpoints_srtm <-   extract_at(     x = srtm,     y = ncpoints,     id = \"pid\",     radius = 1e4L   ) #> Input is a character. Attempt to read it with terra::rast... colnames(ncpoints_srtm_mthr)[2] <- \"mean_par\" ncpoints_compar <- merge(ncpoints_srtm, ncpoints_srtm_mthr) # Are the calculations equal? all.equal(ncpoints_compar$mean, ncpoints_compar$mean_par) #> [1] TRUE ncpoints_s <-   merge(ncpoints, ncpoints_srtm) ncpoints_m <-   merge(ncpoints, ncpoints_srtm_mthr)  plot(ncpoints_s[, \"mean\"], main = \"Single-thread\", pch = 19, cex = 0.33) plot(ncpoints_m[, \"mean_par\"], main = \"Multi-thread\", pch = 19, cex = 0.33) future::plan(future::sequential) mirai::daemons(n = 4L, dispatcher = \"process\") #> [1] 4  system.time(   ncpoints_srtm_mthr <-     par_grid_mirai(       grids = compregions,       fun_dist = extract_at,       x = srtm,       y = ncpoints,       id = \"pid\",       radius = 1e4L,       .standalone = FALSE     ) ) #> ℹ Input is not a character. #>    user  system elapsed  #>   0.083   0.000   8.004  # remove mirai::daemons mirai::daemons(0L) #> [1] 0"},{"path":"https://docs.ropensci.org/chopin/index.html","id":"chopinpar_hierarchy-parallelize-geospatial-computations-using-intrinsic-data-hierarchy","dir":"","previous_headings":"Examples","what":"chopin::par_hierarchy(): parallelize geospatial computations using intrinsic data hierarchy","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"usually nested/exhaustive hierarchies real-world datasets. example, land organized administrative/jurisdictional borders multiple levels exist. U.S. context, state consists several counties, counties split census tracts, group block groups. chopin::par_hierarchy() leverages hierarchies parallelize geospatial operations, means group lower-level geographic units higher-level geography assigned process. demonstration shows census tracts grouped counties county processed CPU thread.","code":""},{"path":"https://docs.ropensci.org/chopin/index.html","id":"read-data","dir":"","previous_headings":"Examples > chopin::par_hierarchy(): parallelize geospatial computations using intrinsic data hierarchy","what":"Read data","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"","code":"# nc_hierarchy.gpkg includes two layers: county and tracts path_nchrchy <- file.path(wdir, \"nc_hierarchy.gpkg\")  nc_data <- path_nchrchy nc_county <- sf::st_read(nc_data, layer = \"county\") #> Reading layer `county' from data source  #>   `/tmp/RtmpmJUPd2/temp_libpath3b3aa268543/chopin/extdata/nc_hierarchy.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 100 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 #> Projected CRS: NAD83 / Conus Albers nc_tracts <- sf::st_read(nc_data, layer = \"tracts\") #> Reading layer `tracts' from data source  #>   `/tmp/RtmpmJUPd2/temp_libpath3b3aa268543/chopin/extdata/nc_hierarchy.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 2672 features and 1 field #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 #> Projected CRS: NAD83 / Conus Albers  # reproject to Conus Albers Equal Area nc_county <- sf::st_transform(nc_county, \"EPSG:5070\") nc_tracts <- sf::st_transform(nc_tracts, \"EPSG:5070\") nc_tracts$COUNTY <- substr(nc_tracts$GEOID, 1, 5)"},{"path":"https://docs.ropensci.org/chopin/index.html","id":"extract-average-srtm-elevations-by-single-and-multiple-threads","dir":"","previous_headings":"Examples > chopin::par_hierarchy(): parallelize geospatial computations using intrinsic data hierarchy","what":"Extract average SRTM elevations by single and multiple threads","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"","code":"future::plan(future.mirai::mirai_multisession, workers = 4L)  # single-thread system.time(   nc_elev_tr_single <-     chopin::extract_at(       x = srtm,       y = nc_tracts,       id = \"GEOID\"     ) ) #> Input is a character. Attempt to read it with terra::rast... #>    user  system elapsed  #>   0.621   0.010   0.613  # hierarchical parallelization system.time(   nc_elev_tr_distr <-     chopin::par_hierarchy(       regions = nc_county, # higher level geometry       regions_id = \"GEOID\", # higher level unique id       fun_dist = extract_at,       x = srtm,       y = nc_tracts, # lower level geometry       id = \"GEOID\", # lower level unique id       func = \"mean\"     ) ) #> ℹ Input is not a character. #> ℹ GEOID is used to stratify the process. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37037 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37001 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37057 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37069 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37155 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37109 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37027 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37063 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37145 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37115 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37151 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37131 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37013 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37159 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37051 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37153 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37093 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37025 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37029 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37169 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37031 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37005 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37139 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37193 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37003 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37083 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37163 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37189 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37173 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37011 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37045 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37125 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37067 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37077 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37185 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37137 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37033 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37107 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37075 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37073 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37161 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37187 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37007 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37135 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37049 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37195 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37061 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37087 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37081 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37099 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37097 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37091 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37149 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37165 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37085 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37105 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37017 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37039 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37035 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37177 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37113 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37143 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37095 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37071 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37101 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37015 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37167 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37079 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37129 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37147 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37141 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37179 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37121 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37133 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37065 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37119 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37199 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37197 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37023 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37191 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37059 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37111 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37183 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37053 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37103 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37041 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37021 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37157 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37117 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37089 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37127 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37009 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37019 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37123 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37181 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37175 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37171 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37043 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37055 is dispatched. #> Input is a character. Attempt to read it with terra::rast...ℹ Your input function at 37047 is dispatched. #>    user  system elapsed  #>   0.419   0.033   7.799"},{"path":"https://docs.ropensci.org/chopin/index.html","id":"par_multirasters-parallelize-over-multiple-rasters","dir":"","previous_headings":"Examples","what":"par_multirasters(): parallelize over multiple rasters","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"common case large group raster files operation performed. chopin::par_multirasters() cases. example demonstrates five elevation raster files calculate average elevation counties North Carolina.","code":"# nccnty <- sf::st_read(nc_data, layer = \"county\") ncelev <- terra::rast(srtm) terra::crs(ncelev) <- \"EPSG:5070\" names(ncelev) <- c(\"srtm15\") tdir <- tempdir()  terra::writeRaster(ncelev, file.path(tdir, \"test1.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test2.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test3.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test4.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test5.tif\"), overwrite = TRUE)  # check if the raster files were exported as expected testfiles <- list.files(tdir, pattern = \"*.tif$\", full.names = TRUE) testfiles #> [1] \"/tmp/RtmpiW9fAm/test1.tif\" \"/tmp/RtmpiW9fAm/test2.tif\" #> [3] \"/tmp/RtmpiW9fAm/test3.tif\" \"/tmp/RtmpiW9fAm/test4.tif\" #> [5] \"/tmp/RtmpiW9fAm/test5.tif\" system.time(   res <-     chopin::par_multirasters(       filenames = testfiles,       fun_dist = extract_at,       x = ncelev,       y = nc_county,       id = \"GEOID\",       func = \"mean\"     ) ) #> ℹ Input is not a character. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at /tmp/RtmpiW9fAm/test1.tif is dispatched. #>  #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at /tmp/RtmpiW9fAm/test2.tif is dispatched. #>  #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at /tmp/RtmpiW9fAm/test3.tif is dispatched. #>  #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at /tmp/RtmpiW9fAm/test4.tif is dispatched. #>  #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at /tmp/RtmpiW9fAm/test5.tif is dispatched. #>    user  system elapsed  #>   1.288   0.090   2.901 knitr::kable(head(res)) # remove temporary raster files file.remove(testfiles) #> [1] TRUE TRUE TRUE TRUE TRUE"},{"path":"https://docs.ropensci.org/chopin/index.html","id":"parallelization-of-a-generic-geospatial-operation","dir":"","previous_headings":"","what":"Parallelization of a generic geospatial operation","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"chopin processing functions, chopin::par_*() functions support generic geospatial operations. example uses terra::nearest(), gets nearest feature’s attributes, inside chopin::par_grid(). figure shows padded grids (50 kilometers), primary roads, points. Primary roads selected padded grid per iteration used calculate distance point nearest primary road. Padded grids overlapping areas look different according padding argument chopin::par_pad_grid().  compare results single-thread multi-thread calculation. Users mindful caveats parallelization nearest feature search, may result excess distance depending distribution target dataset nearest feature searched. example, one wants calculate nearest interstate rural homes fine grids, grids may interstates homes grids get distance nearest interstate. problems can avoided choosing nx, ny, padding values par_pad_grid() meticulously.","code":"path_ncrd1 <- file.path(wdir, \"ncroads_first.gpkg\")  # Generate 5000 random points pnts <- sf::st_sample(nc_county, 5000) pnts <- sf::st_as_sf(pnts) # assign identifiers pnts$pid <- sprintf(\"RPID-%04d\", seq(1, 5000)) rd1 <- sf::st_read(path_ncrd1) #> Reading layer `ncroads_first' from data source  #>   `/tmp/RtmpmJUPd2/temp_libpath3b3aa268543/chopin/extdata/ncroads_first.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 620 features and 4 fields #> Geometry type: MULTILINESTRING #> Dimension:     XY #> Bounding box:  xmin: 1152512 ymin: 1390719 xmax: 1748367 ymax: 1662294 #> Projected CRS: NAD83 / Conus Albers  # reproject pntst <- sf::st_transform(pnts, \"EPSG:5070\") rd1t <- sf::st_transform(rd1, \"EPSG:5070\")  # generate grids nccompreg <-   chopin::par_pad_grid(     input = pntst,     mode = \"grid\",     nx = 4L,     ny = 2L,     padding = 5e4L   ) #> Switch sf class to terra... #> Switch terra class to sf... # plot terra::plot(nccompreg$padded, border = \"orange\") terra::plot(terra::vect(ncsf), add = TRUE) terra::plot(rd1t, col = \"blue\", add = TRUE) #> Warning in plot.sf(rd1t, col = \"blue\", add = TRUE): ignoring all but the first #> attribute terra::plot(pntst, add = TRUE, cex = 0.3) legend(1.02e6, 1.72e6,        legend = c(\"Computation grids (50km padding)\", \"Major roads\"),        lty = 1, lwd = 1, col = c(\"orange\", \"blue\"),        cex = 0.5) # terra::nearest run system.time(   restr <- terra::nearest(x = terra::vect(pntst), y = terra::vect(rd1t)) ) #>    user  system elapsed  #>   0.396   0.000   0.397  pnt_path <- file.path(tdir, \"pntst.gpkg\") sf::st_write(pntst, pnt_path) #> Writing layer `pntst' to data source `/tmp/RtmpiW9fAm/pntst.gpkg' using driver `GPKG' #> Writing 5000 features with 1 fields and geometry type Point.  # we use four threads that were configured above system.time(   resd <-     chopin::par_grid(       grids = nccompreg,       fun_dist = nearest,       x = pnt_path,       y = path_ncrd1,       pad_y = TRUE     ) ) #> ℹ Input is a character. Trying to read with terra . #> ℹ Input is a character. Trying to read with terra . #> ℹ Task at CGRIDID: 1 is successfully dispatched. #>  #> ℹ Input is a character. Trying to read with terra . #> ℹ Input is a character. Trying to read with terra . #> ℹ Task at CGRIDID: 2 is successfully dispatched. #>  #> ℹ Input is a character. Trying to read with terra . #> ℹ Input is a character. Trying to read with terra . #> ℹ Task at CGRIDID: 3 is successfully dispatched. #>  #> ℹ Input is a character. Trying to read with terra . #> ℹ Input is a character. Trying to read with terra . #> ℹ Task at CGRIDID: 4 is successfully dispatched. #>  #> ℹ Input is a character. Trying to read with terra . #> ℹ Input is a character. Trying to read with terra . #> ℹ Task at CGRIDID: 5 is successfully dispatched. #>  #> ℹ Input is a character. Trying to read with terra . #> ℹ Input is a character. Trying to read with terra . #> ℹ Task at CGRIDID: 6 is successfully dispatched. #>  #> ℹ Input is a character. Trying to read with terra . #> ℹ Input is a character. Trying to read with terra . #> ℹ Task at CGRIDID: 7 is successfully dispatched. #>  #> ℹ Input is a character. Trying to read with terra . #> ℹ Input is a character. Trying to read with terra . #> ℹ Task at CGRIDID: 8 is successfully dispatched. #>    user  system elapsed  #>   0.058   0.010   0.401 resj <- merge(restr, resd, by = c(\"from_x\", \"from_y\")) all.equal(resj$distance.x, resj$distance.y) #> [1] TRUE"},{"path":[]},{"path":"https://docs.ropensci.org/chopin/index.html","id":"why-parallelization-is-slower-than-the-ordinary-function-run","dir":"","previous_headings":"Caveats","what":"Why parallelization is slower than the ordinary function run?","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"Parallelization may underperform datasets small take advantage divide--compute approach, parallelization overhead involved. Overhead refers required amount computational resources transferring objects multiple processes. Since demonstrations use quite small datasets, advantage parallelization noticeable expected. large amount data (spatial/temporal resolution number files, example) processed, users find efficiency package. vignette package demonstrates use cases extracting various climate/weather datasets.","code":""},{"path":"https://docs.ropensci.org/chopin/index.html","id":"notes-on-data-restrictions","dir":"","previous_headings":"Caveats","what":"Notes on data restrictions","title":"Computation of Spatial Data by Hierarchical and Objective Partitioning of Inputs for Parallel Processing","text":"chopin works best two-dimensional (planar) geometries. Users disable s2 spherical geometry mode sf setting sf::sf_use_s2(FALSE). Running chopin functions spherical three-dimensional (e.g., including M/Z dimensions) geometries may produce incorrect unexpected results.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/chopin-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Computation of spatial data by hierarchical and objective partitioning of inputs for parallel processing — chopin-package","title":"Computation of spatial data by hierarchical and objective partitioning of inputs for parallel processing — chopin-package","text":"chopin package provides set functions compute divided geospatial data.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/chopin-package.html","id":"basic-functionalities","dir":"Reference","previous_headings":"","what":"Basic functionalities","title":"Computation of spatial data by hierarchical and objective partitioning of inputs for parallel processing — chopin-package","text":"Distribute terra, sf, chopin functions parallel workers set future mirai Set parallelization strategies based artificial grids, equal-size clusters, hierarchy, multiple raster files Convenience functions raster-vector overlay weighted summary vector dataset","code":""},{"path":"https://docs.ropensci.org/chopin/reference/chopin-package.html","id":"chopin-workflow","dir":"Reference","previous_headings":"","what":"chopin workflow","title":"Computation of spatial data by hierarchical and objective partitioning of inputs for parallel processing — chopin-package","text":"simplest way parallelizing generic geospatial computation start par_pad_* functions par_grid, running par_hierarchy, par_multirasters functions .   Example data North Carolinian counties raster elevation data used example data.   demonstrate chopin functions, generate 10,000 random points North Carolina   Creating grids example generate regular grid random point data.   Extracting values raster Since par_* functions operate future backends, users define future plan running functions. multicore plan supports terra objects may lead faster computation, supported Windows. alternative future.mirai's mirai_multisession plan, supported many platforms generally faster plain future multisession plan. workers argument defined integer value specify number threads used.   dispatch multiple extract_at runs grid polygons. proceed, terra object converted sf object.   Hierarchical processing demonstrate hierarchical processing random points using census tract polygons.   example parallelize summarizing mean elevation 10 kilometers circular buffers random sample points first five characters census tract unique identifiers, county codes. example demonstrates hierarchy can defined given polygons unique identifiers suitably formatted defining hierarchy.   Multiraster processing demonstrate multiraster processing random points using multiple rasters.","code":"library(chopin) library(terra) library(sf) library(collapse) library(dplyr) library(future) library(future.mirai) library(future.apply) nccnty_path <- system.file(\"extdata\", \"nc_hierarchy.gpkg\", package = \"chopin\") ncelev_path <-   system.file(\"extdata/nc_srtm15_otm.tif\", package = \"chopin\") nccnty <- terra::vect(nccnty_path) ncelev <- terra::rast(ncelev_path) ncsamp <-   terra::spatSample(     nccnty,     1e4L   ) ncsamp$pid <- 1:nrow(ncsamp) ncgrid <- par_pad_grid(ncsamp, mode = \"grid\", nx = 4L, ny = 2L, padding = 10000) plot(ncgrid$original) future::plan(future.mirai::mirai_multisession, workers = 2L) pg <-   par_grid(     grids = ncgrid,     pad_y = FALSE,     .debug = TRUE,     fun_dist = extract_at,     x = ncelev_path,     y = sf::st_as_sf(ncsamp),     id = \"pid\",     radius = 1e4,     func = \"mean\"   ) nccnty <- sf::st_read(nccnty_path, layer = \"county\") nctrct <- sf::st_read(nccnty_path, layer = \"tracts\") px <-   par_hierarchy(     # from here the par_hierarchy-specific arguments     regions = nctrct,     regions_id = \"GEOID\",     length_left = 5,     pad = 10000,     pad_y = FALSE,     .debug = TRUE,     # from here are the dispatched function definition     # for parallel workers     fun_dist = extract_at,     # below should follow the arguments of the dispatched function     x = ncelev,     y = sf::st_as_sf(ncsamp),     id = \"pid\",     radius = 1e4,     func = \"mean\"   ) ncelev <-   system.file(\"extdata/nc_srtm15_otm.tif\", package = \"chopin\") ncelev <- terra::rast(ncelev) tdir <- tempdir(check = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test1.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test2.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test3.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test4.tif\"), overwrite = TRUE) terra::writeRaster(ncelev, file.path(tdir, \"test5.tif\"), overwrite = TRUE) rasts <- list.files(tdir, pattern = \"tif$\", full.names = TRUE)  pm <-   par_multirasters(     filenames = rasts,     fun_dist = extract_at,     x = NA,     y = sf::st_as_sf(ncsamp)[1:500, ],     id = \"pid\",     radius = 1e4,     func = \"mean\",     .debug = TRUE   )"},{"path":"https://docs.ropensci.org/chopin/reference/chopin-package.html","id":"function-selection-guide-for-par-","dir":"Reference","previous_headings":"","what":"Function selection guide for par_*()","title":"Computation of spatial data by hierarchical and objective partitioning of inputs for parallel processing — chopin-package","text":"provide two flowcharts help users choose right function parallel processing. raster-oriented flowchart users want start raster data, vector-oriented flowchart users large vector data. raster-oriented selection, suggest four factors consider: Number raster files: multiple files, par_multirasters recommended. multiple rasters share extent resolution, consider stacking rasters multilayer SpatRaster object calling terra::rast(filenames). Raster resolution: suggest 100 meters threshold. Rasters resolution coarser 100 meters layers better direct call exactextractr::exact_extract(). Raster extent: Using SpatRaster exactextractr::exact_extract() often minimally affected raster extent. Memory size: max_cells_in_memory argument value exactextractr::exact_extract(), raster resolution, number layers SpatRaster multiplicatively related memory usage. vector-oriented selection, suggest three factors consider: Number features: number features 100,000, consider using par_grid par_hierarchy split data smaller chunks. Hierarchical structure: data hierarchical structure, consider using par_hierarchy parallelize operation. Data grouping: data needs grouped similar sizes, consider using par_pad_balanced par_pad_grid mode = \"grid_quantile\".","code":""},{"path":"https://docs.ropensci.org/chopin/reference/chopin-package.html","id":"caveats","dir":"Reference","previous_headings":"","what":"Caveats","title":"Computation of spatial data by hierarchical and objective partitioning of inputs for parallel processing — chopin-package","text":"parallelization slower ordinary function run? Parallelization may underperform datasets small take advantage divide--compute approach, parallelization overhead involved. Overhead refers required amount computational resources transferring objects multiple processes. Since demonstrations use quite small datasets, advantage parallelization noticeable expected. large amount data (spatial/temporal resolution number files, example) processed, users find efficiency package. vignette package demonstrates use cases extracting various climate/weather datasets. Notes data restrictions chopin works best two-dimensional (planar) geometries. Users disable s2 spherical geometry mode sf setting sf::sf_use_s2(FALSE). Running chopin functions spherical three-dimensional (e.g., including M/Z dimensions) geometries may produce incorrect unexpected results.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/chopin-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Computation of spatial data by hierarchical and objective partitioning of inputs for parallel processing — chopin-package","text":"Maintainer: Insang Song geoissong@gmail.com (ORCID) Authors: Kyle Messier (ORCID) [contributor] contributors: Alec L. Robitaille (Alec reviewed package version 0.6.3 rOpenSci, see <https://github.com/ropensci/software-review/issues/638>) [reviewer] Eric R. Scott (Eric reviewed package version 0.6.3 rOpenSci, see <https://github.com/ropensci/software-review/issues/638>) [reviewer]","code":""},{"path":"https://docs.ropensci.org/chopin/reference/datamod.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the input's GIS data model type — datamod","title":"Return the input's GIS data model type — datamod","text":"function returns one 'vector' 'raster' depending input class.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/datamod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the input's GIS data model type — datamod","text":"","code":"datamod(input)"},{"path":"https://docs.ropensci.org/chopin/reference/datamod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the input's GIS data model type — datamod","text":"input Spat*/sf/stars object.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/datamod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return the input's GIS data model type — datamod","text":"character(1). One \"vector\" \"raster\".","code":""},{"path":"https://docs.ropensci.org/chopin/reference/datamod.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Return the input's GIS data model type — datamod","text":"Although stars object little ambiguous whether classify vector raster, considered raster package.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/datamod.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Return the input's GIS data model type — datamod","text":"Insang Song","code":""},{"path":"https://docs.ropensci.org/chopin/reference/datamod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return the input's GIS data model type — datamod","text":"","code":"if (FALSE) { # \\dontrun{ library(sf) library(terra) options(sf_use_s2 = FALSE)  nc_path <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc_sf <- sf::st_read(nc_path) datamod(nc_sf)  ra_path <- system.file(\"ex/elev.tif\", package = \"terra\") ra <- terra::rast(ra_path) datamod(ra) } # }"},{"path":"https://docs.ropensci.org/chopin/reference/dep_check.html","id":null,"dir":"Reference","previous_headings":"","what":"Return the package the input object is based on — dep_check","title":"Return the package the input object is based on — dep_check","text":"Detect whether input object sf Spat* object.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dep_check.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Return the package the input object is based on — dep_check","text":"","code":"dep_check(input)"},{"path":"https://docs.ropensci.org/chopin/reference/dep_check.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Return the package the input object is based on — dep_check","text":"input Spat* terra sf object.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dep_check.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Return the package the input object is based on — dep_check","text":"character object; one \"character\", \"terra\" \"sf\"","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/dep_check.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Return the package the input object is based on — dep_check","text":"Insang Song","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dep_check.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Return the package the input object is based on — dep_check","text":"","code":"if (FALSE) { # \\dontrun{ library(sf) library(terra) options(sf_use_s2 = FALSE)  nc_path <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc_sf <- sf::st_read(nc_path) dep_check(nc_sf) nc_vect <- terra::vect(nc_sf) dep_check(nc_vect) } # }"},{"path":"https://docs.ropensci.org/chopin/reference/dep_switch.html","id":null,"dir":"Reference","previous_headings":"","what":"Switch spatial data class — dep_switch","title":"Switch spatial data class — dep_switch","text":"Convert class sf/stars-terra","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dep_switch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Switch spatial data class — dep_switch","text":"","code":"dep_switch(input)"},{"path":"https://docs.ropensci.org/chopin/reference/dep_switch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Switch spatial data class — dep_switch","text":"input Spat* terra sf object.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dep_switch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Switch spatial data class — dep_switch","text":"Data converted package class (sf, terra; terra, sf)","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/dep_switch.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Switch spatial data class — dep_switch","text":"Insang Song","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dep_switch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Switch spatial data class — dep_switch","text":"","code":"if (FALSE) { # \\dontrun{ library(sf) library(stars) library(terra) options(sf_use_s2 = FALSE)  ## generate a random raster ras_rand <- terra::rast(nrow = 30, ncol = 30) terra::values(ras_rand) <- runif(900) stars_rand <- dep_switch(ras_rand) stars_rand inherits(sf_rand, \"stars\") # TRUE # should return stars object  vec_rand <- terra::spatSample(ras_rand, size = 10L, as.points = TRUE) sf_rand <- dep_switch(vec_rand) inherits(sf_rand, \"sf\") # TRUE sf_rand # should return sf object } # }"},{"path":"https://docs.ropensci.org/chopin/reference/dot-check_character.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the class of an input object — .check_character","title":"Check the class of an input object — .check_character","text":"function checks class input object returns \"raster\" raster object, \"vector\" vector object.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dot-check_character.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the class of an input object — .check_character","text":"","code":".check_character(input)"},{"path":"https://docs.ropensci.org/chopin/reference/dot-check_character.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the class of an input object — .check_character","text":"input input object checked","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dot-check_character.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check the class of an input object — .check_character","text":"character string indicating class input object (\"raster\" \"vector\")","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dot-check_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Raster Input — .check_raster","title":"Check Raster Input — .check_raster","text":"function checks input object ensure valid raster object character path raster file. also provides warnings informative messages based input type.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dot-check_raster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Raster Input — .check_raster","text":"","code":".check_raster(input, extent = NULL, ...)"},{"path":"https://docs.ropensci.org/chopin/reference/dot-check_raster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Raster Input — .check_raster","text":"input input object checked. can either SpatRaster object character path raster file. extent extent raster. Defaults NULL. Numeric vector put order c(xmin, xmax, ymin, ymax). ... Placeholder.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dot-check_raster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Raster Input — .check_raster","text":"validated input object.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dot-check_raster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check Raster Input — .check_raster","text":"","code":"if (FALSE) { # \\dontrun{ .check_raster(system.file(\"extdata/nc_srtm15_otm.tif\", package = \"chopin\")) } # }"},{"path":"https://docs.ropensci.org/chopin/reference/dot-check_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Check the subject object and perform necessary conversions if needed. — .check_vector","title":"Check the subject object and perform necessary conversions if needed. — .check_vector","text":"function checks class input object performs necessary conversions needed.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dot-check_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check the subject object and perform necessary conversions if needed. — .check_vector","text":"","code":".check_vector(   input,   input_id = NULL,   extent = NULL,   out_class = character(1),   ... )"},{"path":"https://docs.ropensci.org/chopin/reference/dot-check_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check the subject object and perform necessary conversions if needed. — .check_vector","text":"input sf/SpatVector/character. input object checked. input_id character(1). ID field subject object. extent numeric(4). extent subject object. Numeric vector put order c(xmin, xmax, ymin, ymax). out_class character(1). class output object. one c(\"sf\", \"terra\"). ... Placeholder.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dot-check_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check the subject object and perform necessary conversions if needed. — .check_vector","text":"checked converted subject object.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dot-check_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check the subject object and perform necessary conversions if needed. — .check_vector","text":"","code":"if (FALSE) { # \\dontrun{ # Check a SpatVector object ncpath <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc <- terra::vect(ncpath) extent <- c(-80, -77, 35, 36) .check_vector(input = nc, extent = extent, input_id = \"FIPS\")  # Check a sf object ncsf <- sf::st_read(ncpath) .check_vector(input = ncsf, extent = extent, input_id = \"FIPS\")  # Check a character object .check_vector(   input = ncpath,   extent = extent,   out_class = \"terra\",   input_id = \"FIPS\" ) } # }"},{"path":"https://docs.ropensci.org/chopin/reference/dot-intersect_extent.html","id":null,"dir":"Reference","previous_headings":"","what":"Get intersection extent — .intersect_extent","title":"Get intersection extent — .intersect_extent","text":"Get intersection extent","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dot-intersect_extent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get intersection extent — .intersect_extent","text":"","code":".intersect_extent(input, out_class, ...)  # S4 method for class 'sf,ANY' .intersect_extent(input, out_class = NULL, ...)  # S4 method for class 'SpatExtent,ANY' .intersect_extent(input, out_class = NULL, ...)  # S4 method for class 'SpatVector,ANY' .intersect_extent(input, out_class = NULL, ...)  # S4 method for class 'numeric,character' .intersect_extent(input, out_class = NULL, ...)"},{"path":"https://docs.ropensci.org/chopin/reference/dot-intersect_extent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get intersection extent — .intersect_extent","text":"input sf/SpatExtent/SpatVector/numeric out_class character(1). \"sf\" \"terra\" ... arguments. Placeholder.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dot-par_screen.html","id":null,"dir":"Reference","previous_headings":"","what":"Prescreen input data for parallelization — .par_screen","title":"Prescreen input data for parallelization — .par_screen","text":"function takes input object type character ingest input object return object desired class.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/dot-par_screen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prescreen input data for parallelization — .par_screen","text":"","code":".par_screen(type, input, input_id = NULL, out_class = \"terra\", .window = NULL)"},{"path":"https://docs.ropensci.org/chopin/reference/dot-par_screen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prescreen input data for parallelization — .par_screen","text":"type character(1). \"raster\" \"vector\". input object. Input object. input_id character(1). Default NULL. NULL, function check object ID column. out_class character(1). Default NULL, one c(\"sf\", \"terra\"). Default \"terra\". .window numeric(4)/SpatExtent/st_bbox object. Loading window.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/extract_at.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract raster values with point buffers or polygons — extract_at","title":"Extract raster values with point buffers or polygons — extract_at","text":"Extract raster values point buffers polygons","code":""},{"path":"https://docs.ropensci.org/chopin/reference/extract_at.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract raster values with point buffers or polygons — extract_at","text":"","code":"extract_at(x, y, ...)  # S4 method for class 'SpatRaster,sf' extract_at(   x = NULL,   y = NULL,   id = NULL,   func = \"mean\",   extent = NULL,   radius = NULL,   out_class = \"sf\",   kernel = NULL,   kernel_func = stats::weighted.mean,   bandwidth = NULL,   max_cells = 3e+07,   .standalone = TRUE,   ... )  # S4 method for class 'character,character' extract_at(   x = NULL,   y = NULL,   id = NULL,   func = \"mean\",   extent = NULL,   radius = NULL,   out_class = \"sf\",   kernel = NULL,   kernel_func = stats::weighted.mean,   bandwidth = NULL,   max_cells = 3e+07,   .standalone = TRUE,   ... )  # S4 method for class 'SpatRaster,character' extract_at(   x = NULL,   y = NULL,   id = NULL,   func = \"mean\",   extent = NULL,   radius = NULL,   out_class = \"sf\",   kernel = NULL,   kernel_func = stats::weighted.mean,   bandwidth = NULL,   max_cells = 3e+07,   .standalone = TRUE,   ... )  # S4 method for class 'SpatRaster,SpatVector' extract_at(   x = NULL,   y = NULL,   id = NULL,   func = \"mean\",   extent = NULL,   radius = NULL,   out_class = \"sf\",   kernel = NULL,   kernel_func = stats::weighted.mean,   bandwidth = NULL,   max_cells = 3e+07,   .standalone = TRUE,   ... )  # S4 method for class 'character,sf' extract_at(   x = NULL,   y = NULL,   id = NULL,   func = \"mean\",   extent = NULL,   radius = NULL,   out_class = \"sf\",   kernel = NULL,   kernel_func = stats::weighted.mean,   bandwidth = NULL,   max_cells = 3e+07,   .standalone = TRUE,   ... )  # S4 method for class 'character,SpatVector' extract_at(   x = NULL,   y = NULL,   id = NULL,   func = \"mean\",   extent = NULL,   radius = NULL,   out_class = \"sf\",   kernel = NULL,   kernel_func = stats::weighted.mean,   bandwidth = NULL,   max_cells = 3e+07,   .standalone = TRUE,   ... )"},{"path":"https://docs.ropensci.org/chopin/reference/extract_at.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract raster values with point buffers or polygons — extract_at","text":"x SpatRaster object file path(s) extensions GDAL-compatible. multiple file paths used, rasters must extent resolution. y sf/SpatVector object file path. ... Placeholder. id character(1). Unique identifier point. func function taking one numeric vector argument. Default \"mean\" supported signatures arguments x y. extent numeric(4) SpatExtent. Extent clipping vector. works points character(1) file path. radius numeric(1). Buffer radius. out_class character(1). Output class. One sf terra. kernel character(1). Name kernel function One \"uniform\", \"triweight\", \"quartic\", \"epanechnikov\" kernel_func function. Kernel function apply extracted values. Default stats::weighted.mean() bandwidth numeric(1). Kernel bandwidth. max_cells integer(1). Maximum number cells memory. .standalone logical(1). Default TRUE, means function executed standalone mode. using function par_* functions, set FALSE.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/extract_at.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract raster values with point buffers or polygons — extract_at","text":"data.frame object summarized raster values respect mode (polygon buffer) function.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/extract_at.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract raster values with point buffers or polygons — extract_at","text":"Inputs preprocessed different ways depending class. Vector inputs y: sf preferred, thus character SpatVector inputs converted sf object. radius NULL, sf::st_buffer used generate circular buffers subsequent raster-vector overlay done exactextractr::exact_extract. Raster input x: SpatRaster preferred. input SpatRaster, converted SpatRaster object.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/extract_at.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract raster values with point buffers or polygons — extract_at","text":"Insang Song geoissong@gmail.com","code":""},{"path":"https://docs.ropensci.org/chopin/reference/extract_at.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract raster values with point buffers or polygons — extract_at","text":"","code":"ncpath <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") rastpath <- system.file(\"extdata/nc_srtm15_otm.tif\", package = \"chopin\")  nc <- terra::vect(ncpath) nc <- terra::project(nc, \"EPSG:5070\") rrast <- terra::rast(nc, nrow = 100, ncol = 220) ncr <- terra::rasterize(nc, rrast) terra::values(rrast) <- rgamma(2.2e4, 4, 2) rpnt <- terra::spatSample(rrast, 16L, as.points = TRUE) rpnt$pid <- sprintf(\"ID-%02d\", seq(1, 16))  extract_at(rrast, rpnt, \"pid\", \"mean\", radius = 1000) #> Switch terra class to sf... #>      pid      mean #> 1  ID-01 1.9822181 #> 2  ID-02 3.4319303 #> 3  ID-03 3.9273467 #> 4  ID-04 0.2887684 #> 5  ID-05 1.0191861 #> 6  ID-06 1.4394057 #> 7  ID-07 3.3074858 #> 8  ID-08 3.7643454 #> 9  ID-09 1.9196675 #> 10 ID-10 3.5066707 #> 11 ID-11 1.7782122 #> 12 ID-12 0.7785873 #> 13 ID-13 2.0458317 #> 14 ID-14 1.1224172 #> 15 ID-15 3.9863422 #> 16 ID-16 2.9632106 extract_at(rrast, nc, \"NAME\", \"mean\") #> Switch terra class to sf... #>             NAME     mean #> 1           Ashe 1.947373 #> 2      Alleghany 1.967829 #> 3          Surry 1.979166 #> 4      Currituck 2.087910 #> 5    Northampton 1.995594 #> 6       Hertford 2.055209 #> 7         Camden 2.007728 #> 8          Gates 1.988871 #> 9         Warren 2.030988 #> 10        Stokes 1.948884 #> 11       Caswell 2.259268 #> 12    Rockingham 1.933299 #> 13     Granville 1.968687 #> 14        Person 2.050681 #> 15         Vance 2.038219 #> 16       Halifax 2.146035 #> 17    Pasquotank 1.876140 #> 18        Wilkes 1.915930 #> 19       Watauga 1.895659 #> 20    Perquimans 1.864217 #> 21        Chowan 2.067043 #> 22         Avery 2.087230 #> 23        Yadkin 2.030065 #> 24      Franklin 1.952211 #> 25       Forsyth 2.081105 #> 26      Guilford 1.971966 #> 27      Alamance 1.851238 #> 28        Bertie 1.861859 #> 29        Orange 1.943087 #> 30        Durham 2.267795 #> 31          Nash 2.116158 #> 32      Mitchell 2.020657 #> 33     Edgecombe 2.139695 #> 34      Caldwell 2.003155 #> 35        Yancey 1.859101 #> 36        Martin 1.997451 #> 37          Wake 1.919050 #> 38       Madison 1.956670 #> 39       Iredell 1.979587 #> 40         Davie 2.242482 #> 41     Alexander 1.812352 #> 42      Davidson 2.031530 #> 43         Burke 1.928711 #> 44    Washington 2.051171 #> 45       Tyrrell 2.120135 #> 46      McDowell 1.951835 #> 47      Randolph 1.997758 #> 48       Chatham 1.956705 #> 49        Wilson 2.065757 #> 50         Rowan 1.879678 #> 51          Pitt 1.969185 #> 52       Catawba 2.094098 #> 53      Buncombe 2.115458 #> 54      Johnston 2.030401 #> 55       Haywood 1.925160 #> 56          Dare 2.003897 #> 57      Beaufort 1.995803 #> 58         Swain 1.994998 #> 59        Greene 1.892638 #> 60           Lee 1.786678 #> 61    Rutherford 2.080518 #> 62         Wayne 2.036684 #> 63       Harnett 2.025692 #> 64     Cleveland 2.155510 #> 65       Lincoln 2.243986 #> 66       Jackson 2.097023 #> 67         Moore 2.074824 #> 68   Mecklenburg 1.946314 #> 69      Cabarrus 1.985481 #> 70    Montgomery 1.982317 #> 71        Stanly 1.831049 #> 72     Henderson 2.046894 #> 73        Graham 1.807232 #> 74        Lenoir 1.992871 #> 75  Transylvania 2.139632 #> 76        Gaston 1.860922 #> 77          Polk 2.001914 #> 78         Macon 2.087482 #> 79       Sampson 2.149409 #> 80       Pamlico 1.884407 #> 81      Cherokee 1.974882 #> 82    Cumberland 1.973618 #> 83         Jones 1.979062 #> 84         Union 1.981821 #> 85         Anson 2.053536 #> 86          Hoke 1.982203 #> 87          Hyde 2.087412 #> 88        Duplin 2.001717 #> 89      Richmond 2.093529 #> 90          Clay 1.872937 #> 91        Craven 1.985508 #> 92      Scotland 1.972783 #> 93        Onslow 1.982929 #> 94       Robeson 2.052696 #> 95      Carteret 2.064198 #> 96        Bladen 2.083966 #> 97        Pender 1.920480 #> 98      Columbus 2.075436 #> 99   New Hanover 1.874862 #> 100    Brunswick 1.911671 extract_at(rrast, ncpath, \"NAME\", \"mean\") #> ℹ Input is a character. Trying to read with sf. #> Reading layer `nc.gpkg' from data source  #>   `/usr/local/lib/R/site-library/sf/gpkg/nc.gpkg' using driver `GPKG' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 #>             NAME     mean #> 1           Ashe 1.947373 #> 2      Alleghany 1.967829 #> 3          Surry 1.979166 #> 4      Currituck 2.087910 #> 5    Northampton 1.995594 #> 6       Hertford 2.055209 #> 7         Camden 2.007728 #> 8          Gates 1.988871 #> 9         Warren 2.030988 #> 10        Stokes 1.948884 #> 11       Caswell 2.259268 #> 12    Rockingham 1.933299 #> 13     Granville 1.968687 #> 14        Person 2.050681 #> 15         Vance 2.038219 #> 16       Halifax 2.146035 #> 17    Pasquotank 1.876140 #> 18        Wilkes 1.915930 #> 19       Watauga 1.895659 #> 20    Perquimans 1.864217 #> 21        Chowan 2.067043 #> 22         Avery 2.087230 #> 23        Yadkin 2.030065 #> 24      Franklin 1.952211 #> 25       Forsyth 2.081105 #> 26      Guilford 1.971966 #> 27      Alamance 1.851238 #> 28        Bertie 1.861859 #> 29        Orange 1.943087 #> 30        Durham 2.267795 #> 31          Nash 2.116158 #> 32      Mitchell 2.020657 #> 33     Edgecombe 2.139695 #> 34      Caldwell 2.003155 #> 35        Yancey 1.859101 #> 36        Martin 1.997451 #> 37          Wake 1.919050 #> 38       Madison 1.956670 #> 39       Iredell 1.979587 #> 40         Davie 2.242482 #> 41     Alexander 1.812352 #> 42      Davidson 2.031530 #> 43         Burke 1.928711 #> 44    Washington 2.051171 #> 45       Tyrrell 2.120135 #> 46      McDowell 1.951835 #> 47      Randolph 1.997758 #> 48       Chatham 1.956705 #> 49        Wilson 2.065757 #> 50         Rowan 1.879678 #> 51          Pitt 1.969185 #> 52       Catawba 2.094098 #> 53      Buncombe 2.115458 #> 54      Johnston 2.030401 #> 55       Haywood 1.925160 #> 56          Dare 2.003897 #> 57      Beaufort 1.995803 #> 58         Swain 1.994998 #> 59        Greene 1.892638 #> 60           Lee 1.786678 #> 61    Rutherford 2.080518 #> 62         Wayne 2.036684 #> 63       Harnett 2.025692 #> 64     Cleveland 2.155510 #> 65       Lincoln 2.243986 #> 66       Jackson 2.097023 #> 67         Moore 2.074824 #> 68   Mecklenburg 1.946314 #> 69      Cabarrus 1.985481 #> 70    Montgomery 1.982317 #> 71        Stanly 1.831049 #> 72     Henderson 2.046894 #> 73        Graham 1.807232 #> 74        Lenoir 1.992871 #> 75  Transylvania 2.139632 #> 76        Gaston 1.860922 #> 77          Polk 2.001914 #> 78         Macon 2.087482 #> 79       Sampson 2.149409 #> 80       Pamlico 1.884407 #> 81      Cherokee 1.974882 #> 82    Cumberland 1.973618 #> 83         Jones 1.979062 #> 84         Union 1.981821 #> 85         Anson 2.053536 #> 86          Hoke 1.982203 #> 87          Hyde 2.087412 #> 88        Duplin 2.001717 #> 89      Richmond 2.093529 #> 90          Clay 1.872937 #> 91        Craven 1.985508 #> 92      Scotland 1.972783 #> 93        Onslow 1.982929 #> 94       Robeson 2.052696 #> 95      Carteret 2.064198 #> 96        Bladen 2.083966 #> 97        Pender 1.920480 #> 98      Columbus 2.075436 #> 99   New Hanover 1.874862 #> 100    Brunswick 1.911671 extract_at(   rrast, ncpath, \"NAME\", \"mean\",   kernel = \"epanechnikov\",   bandwidth = 1e5 ) #> ℹ Input is a character. Trying to read with sf. #> Reading layer `nc.gpkg' from data source  #>   `/usr/local/lib/R/site-library/sf/gpkg/nc.gpkg' using driver `GPKG' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 #> Kernel function [ epanechnikov ] is applied to calculate weights... #> Switch sf class to terra... #> Warning: Point geometries are acceptable for kernel weighting. Convert to points... #> (Note: inside = TRUE is applied) #> # A tibble: 100 × 2 #>    NAME      value #>    <chr>     <dbl> #>  1 Alamance   1.85 #>  2 Alexander  1.81 #>  3 Alleghany  1.97 #>  4 Anson      2.06 #>  5 Ashe       1.95 #>  6 Avery      2.08 #>  7 Beaufort   1.99 #>  8 Bertie     1.86 #>  9 Bladen     2.08 #> 10 Brunswick  1.92 #> # ℹ 90 more rows extract_at(   rastpath, ncpath, \"NAME\", \"mean\",   kernel = \"epanechnikov\",   bandwidth = 1e5 ) #> Input is a character. Attempt to read it with terra::rast... #> ℹ Input is a character. Trying to read with sf. #> Reading layer `nc.gpkg' from data source  #>   `/usr/local/lib/R/site-library/sf/gpkg/nc.gpkg' using driver `GPKG' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 #> Kernel function [ epanechnikov ] is applied to calculate weights... #> Switch sf class to terra... #> Warning: Point geometries are acceptable for kernel weighting. Convert to points... #> (Note: inside = TRUE is applied) #> # A tibble: 100 × 2 #>    NAME       value #>    <chr>      <dbl> #>  1 Alamance   189.  #>  2 Alexander  358.  #>  3 Alleghany  877.  #>  4 Anson      106.  #>  5 Ashe       981.  #>  6 Avery     1086.  #>  7 Beaufort    11.8 #>  8 Bertie      18.9 #>  9 Bladen      26.7 #> 10 Brunswick   11.7 #> # ℹ 90 more rows"},{"path":"https://docs.ropensci.org/chopin/reference/get_clip_ext.html","id":null,"dir":"Reference","previous_headings":"","what":"Setting the clipping extent — get_clip_ext","title":"Setting the clipping extent — get_clip_ext","text":"Return clipping extent buffer radius. assumes input CRS projected linear unit meters.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/get_clip_ext.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Setting the clipping extent — get_clip_ext","text":"","code":"get_clip_ext(pnts, radius, extrusion = 1.1)"},{"path":"https://docs.ropensci.org/chopin/reference/get_clip_ext.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Setting the clipping extent — get_clip_ext","text":"pnts One sf SpatVector object. Target points computation. radius numeric(1). Buffer radius. assumed meters extrusion numeric(1). extent extrusion factor. Default 1.1, meaning actual padding 10 percent wider radius.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/get_clip_ext.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Setting the clipping extent — get_clip_ext","text":"terra::ext sfc_POLYGON object computation extent.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/get_clip_ext.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Setting the clipping extent — get_clip_ext","text":"Insang Song","code":""},{"path":"https://docs.ropensci.org/chopin/reference/get_clip_ext.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Setting the clipping extent — get_clip_ext","text":"","code":"if (FALSE) { # \\dontrun{ library(sf) library(terra) options(sf_use_s2 = FALSE)  nc_path <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc_sf <- sf::st_read(nc_path) nc_sf <- sf::st_transform(nc_sf, \"EPSG:5070\") get_clip_ext(nc_sf, 2.5e4) nc_vect <- terra::vect(nc_sf) get_clip_ext(nc_vect, 2.5e4) } # }"},{"path":"https://docs.ropensci.org/chopin/reference/indexing.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset for nonidentical package class objects — indexing","title":"Subset for nonidentical package class objects — indexing","text":"Subset nonidentical package class objects Intersect different data model objects","code":""},{"path":"https://docs.ropensci.org/chopin/reference/indexing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset for nonidentical package class objects — indexing","text":"","code":"# S4 method for class 'SpatVector,bbox,missing,ANY' x[i, j]  # S4 method for class 'SpatVector,sf,missing,ANY' x[i, j]  # S4 method for class 'SpatVector,sfc,missing,ANY' x[i, j]  # S4 method for class 'SpatVector,SpatExtent,missing,ANY' x[i, j]  .intersect(x, y)"},{"path":"https://docs.ropensci.org/chopin/reference/indexing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset for nonidentical package class objects — indexing","text":"x SpatVector/sf/SpatRaster object intersected. Dataset used subset x. j Column indices names. y SpatVector/sf object. Intersecting object.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/kernelfunction.html","id":null,"dir":"Reference","previous_headings":"","what":"Kernel functions — kernelfunction","title":"Kernel functions — kernelfunction","text":"Kernel functions","code":""},{"path":"https://docs.ropensci.org/chopin/reference/kernelfunction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kernel functions — kernelfunction","text":"","code":"kernelfunction(   d,   bw,   kernel = c(\"uniform\", \"quartic\", \"triweight\", \"epanechnikov\") )"},{"path":"https://docs.ropensci.org/chopin/reference/kernelfunction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kernel functions — kernelfunction","text":"d Distance bw Bandwidth kernel kernel Kernel type. One \"uniform\", \"quartic\", \"triweight\", \"epanechnikov\"","code":""},{"path":"https://docs.ropensci.org/chopin/reference/kernelfunction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kernel functions — kernelfunction","text":"numeric. Kernel weights.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/kernelfunction.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Kernel functions — kernelfunction","text":"https://github.com/JanCaha/SpatialKDE","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/kernelfunction.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kernel functions — kernelfunction","text":"","code":"v_dist <- c(1, 10, 100, 25, 50, 0.1) bw_dist1 <- 1 bw_dist2 <- 10 kernelfunction(v_dist, bw_dist1, \"uniform\") #> [1] 0.5 0.0 0.0 0.0 0.0 0.5 kernelfunction(v_dist, bw_dist1, \"quartic\") #> [1] 0.0000000 0.0000000 0.0000000 0.0000000 0.0000000 0.9188437 kernelfunction(v_dist, bw_dist1, \"triweight\") #> [1] 0.000 0.000 0.000 0.000 0.000 0.999 kernelfunction(v_dist, bw_dist1, \"epanechnikov\") #> [1] 0.0000 0.0000 0.0000 0.0000 0.0000 0.7425 kernelfunction(v_dist, bw_dist2, \"uniform\") #> [1] 0.5 0.5 0.0 0.0 0.0 0.5 kernelfunction(v_dist, bw_dist2, \"quartic\") #> [1] 0.9188437 0.0000000 0.0000000 0.0000000 0.0000000 0.9373125 kernelfunction(v_dist, bw_dist2, \"triweight\") #> [1] 0.999000 0.000000 0.000000 0.000000 0.000000 0.999999 kernelfunction(v_dist, bw_dist2, \"epanechnikov\") #> [1] 0.742500 0.000000 0.000000 0.000000 0.000000 0.749925"},{"path":"https://docs.ropensci.org/chopin/reference/ncpoints.html","id":null,"dir":"Reference","previous_headings":"","what":"Mildly clustered points in North Carolina, United States — ncpoints","title":"Mildly clustered points in North Carolina, United States — ncpoints","text":"Mildly clustered points North Carolina, United States","code":""},{"path":"https://docs.ropensci.org/chopin/reference/ncpoints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mildly clustered points in North Carolina, United States — ncpoints","text":"","code":"ncpoints"},{"path":"https://docs.ropensci.org/chopin/reference/ncpoints.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Mildly clustered points in North Carolina, United States — ncpoints","text":"data frame 2,304 rows two variables: X X coordinate Y Y coordinate","code":""},{"path":"https://docs.ropensci.org/chopin/reference/ncpoints.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Mildly clustered points in North Carolina, United States — ncpoints","text":"sf package data nc","code":""},{"path":"https://docs.ropensci.org/chopin/reference/ncpoints.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Mildly clustered points in North Carolina, United States — ncpoints","text":"Coordinates EPSG:5070 (Conus Albers Equal Area)","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/ncpoints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mildly clustered points in North Carolina, United States — ncpoints","text":"","code":"data(\"ncpoints\", package = \"chopin\")"},{"path":"https://docs.ropensci.org/chopin/reference/par_convert_f.html","id":null,"dir":"Reference","previous_headings":"","what":"Map arguments to the desired names — par_convert_f","title":"Map arguments to the desired names — par_convert_f","text":"function maps arguments target function desired names. Users use named list name_match standardize argument names, least x y, target function. function particularly useful parallelize functions spatial data outside sf terra packages arguments named x /y. par_* functions detect functions wrapping nonstandardized functions parallelize computation.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_convert_f.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Map arguments to the desired names — par_convert_f","text":"","code":"par_convert_f(fun, arg_map)"},{"path":"https://docs.ropensci.org/chopin/reference/par_convert_f.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Map arguments to the desired names — par_convert_f","text":"fun function map arguments. arg_map named character vector. c(x = \"\", y = \"\") map fun x y, respectively.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_convert_f.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Map arguments to the desired names — par_convert_f","text":"Function arguments mapped.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_convert_f.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Map arguments to the desired names — par_convert_f","text":"arg_map defined carefully according characteristics fun. mapping x y, resultant function fail remain arguments without default. recommended map arguments fun avoid side effects.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_convert_f.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Map arguments to the desired names — par_convert_f","text":"","code":"cov_map <- arg_mapping <- c(x = \"a\", y = \"b\", z = \"c\", w = \"d\") # Example original function f1 <- function(a, b, c, d) {   return(a + b + c + d) } # Mapping of new argument names to original argument names arg_mapping <- c(x = \"a\", y = \"b\", z = \"c\", w = \"d\") f2 <- par_convert_f(f1, arg_mapping)  # demonstrate f2 with the mapped arguments f2(x = 1, y = 2, z = -1, w = 10) #> [1] 12"},{"path":"https://docs.ropensci.org/chopin/reference/par_cut_coords.html","id":null,"dir":"Reference","previous_headings":"","what":"Partition coordinates into quantile polygons — par_cut_coords","title":"Partition coordinates into quantile polygons — par_cut_coords","text":"Partition coordinates quantile polygons","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_cut_coords.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partition coordinates into quantile polygons — par_cut_coords","text":"","code":"par_cut_coords(x = NULL, y = NULL, quantiles)"},{"path":"https://docs.ropensci.org/chopin/reference/par_cut_coords.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partition coordinates into quantile polygons — par_cut_coords","text":"x numeric/sf/SpatVector. x-coordinates (numeric). y numeric. y-coordinates. quantiles numeric vector. Quantiles.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_cut_coords.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Partition coordinates into quantile polygons — par_cut_coords","text":"SpatVector object field CGRIDID.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_cut_coords.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Partition coordinates into quantile polygons — par_cut_coords","text":"function two-dimensional points.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/par_cut_coords.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Partition coordinates into quantile polygons — par_cut_coords","text":"","code":"if (FALSE) { # \\dontrun{ library(terra)  random_points <-   data.frame(x = runif(1000, 0, 100), y = runif(1000, 0, 100)) quantiles <- seq(0, 1, length.out = 5L) qpoly <- par_cut_coords(random_points$x, random_points$y, quantiles) clustered_points <-   data.frame(x = rgamma(1000, 1, 1), y = rgamma(1000, 4, 1))  qpoly_c <- par_cut_coords(clustered_points$x, clustered_points$y, quantiles)  par(mfcol = c(1, 2)) plot(qpoly) plot(qpoly_c) par(mfcol = c(1, 1))  cvect <- terra::vect(clustered_points, geom = c(\"x\", \"y\")) plot(cvect) plot(qpoly_c, add = TRUE, col = \"transparent\", border = \"red\")  qcv <- intersect(cvect, qpoly_c) table(qcv$CGRIDID) sum(table(qcv$CGRIDID)) # should be 1000 } # }"},{"path":"https://docs.ropensci.org/chopin/reference/par_def_q.html","id":null,"dir":"Reference","previous_headings":"","what":"Quantile definition — par_def_q","title":"Quantile definition — par_def_q","text":"Quantile definition","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_def_q.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quantile definition — par_def_q","text":"","code":"par_def_q(steps = 4L)"},{"path":"https://docs.ropensci.org/chopin/reference/par_def_q.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quantile definition — par_def_q","text":"steps integer(1). number quantiles.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_def_q.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quantile definition — par_def_q","text":"numeric vector quantiles.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/par_def_q.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quantile definition — par_def_q","text":"","code":"if (FALSE) { # \\dontrun{ par_def_q(5L) } # }"},{"path":"https://docs.ropensci.org/chopin/reference/par_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelize spatial computation over the computational grids — par_grid","title":"Parallelize spatial computation over the computational grids — par_grid","text":"future::multicore, future::multisession, future::cluster future.mirai::mirai_multisession future::plan parallelize work grid. details terminology future package, refer future::plan. function assumes users one raster file sizable spatially distributed target locations. thread process nearest integer $|N_g| / |N_t|$ grids $|N_g|$ denotes number grids $|N_t|$ denotes number threads.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelize spatial computation over the computational grids — par_grid","text":"","code":"par_grid(grids, fun_dist, ..., pad_y = FALSE, .debug = FALSE)"},{"path":"https://docs.ropensci.org/chopin/reference/par_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelize spatial computation over the computational grids — par_grid","text":"grids List two sf/SpatVector objects. Computational grids. takes strict assumption grid input output `par_pad_grid“. fun_dist sf, terra chopin functions. function x y arguments. ... Arguments passed argument fun_dist. pad_y logical(1). Whether filter y padded grid. TRUE x values calculated. Default FALSE. reverse case, like terra::extent exactextractr::exact_extract, raster (x) extent set padded grid. .debug logical(1). Default FALSE. Otherwise, unit computation fails, error message CGRIDID value error occurred included output.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallelize spatial computation over the computational grids — par_grid","text":"data.frame object computation results. entries results, consult documentation function put fun_dist argument.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_grid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Parallelize spatial computation over the computational grids — par_grid","text":"dynamic dots (...), fun_dist arguments include x y sf/terra class objects file paths accepted. Virtually sf/terra functions accept two arguments can put fun_dist, please advised spatial operations necessarily give exact result done single-thread. example, distance calculated function may return lower value actual computational region reduced. case especially target features spatially sparsely distributed.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/par_grid.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parallelize spatial computation over the computational grids — par_grid","text":"Insang Song geoissong@gmail.com","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parallelize spatial computation over the computational grids — par_grid","text":"","code":"library(sf) #> Linking to GEOS 3.12.1, GDAL 3.8.4, PROJ 9.4.0; sf_use_s2() is TRUE library(future) library(future.mirai) plan(mirai_multisession, workers = 2) ncpath <- system.file(\"shape/nc.shp\", package = \"sf\") ncpoly <- sf::st_read(ncpath) #> Reading layer `nc' from data source  #>   `/usr/local/lib/R/site-library/sf/shape/nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 # sf object ncpnts <-   readRDS(     system.file(\"extdata/nc_random_point.rds\", package = \"chopin\")   ) # file path ncelev <-     system.file(\"extdata/nc_srtm15_otm.tif\", package = \"chopin\")  nccompreg <-   chopin::par_pad_grid(     input = ncpnts,     mode = \"grid\",     nx = 4L,     ny = 2L,     padding = 5e3L   ) #> Switch sf class to terra... #> Switch terra class to sf... res <-   par_grid(     grids = nccompreg,     fun_dist = extract_at,     x = ncelev,     y = ncpnts,     qsegs = 90L,     radius = 5e3L,     id = \"pid\"   ) #> Spherical geometry (s2) switched off #> ℹ Input is not a character. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Task at CGRIDID: 1 is successfully dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Task at CGRIDID: 2 is successfully dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Task at CGRIDID: 3 is successfully dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Task at CGRIDID: 4 is successfully dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Task at CGRIDID: 5 is successfully dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Task at CGRIDID: 6 is successfully dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Task at CGRIDID: 7 is successfully dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Task at CGRIDID: 8 is successfully dispatched."},{"path":"https://docs.ropensci.org/chopin/reference/par_grid_mirai.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelize spatial computation over the computational grids — par_grid_mirai","title":"Parallelize spatial computation over the computational grids — par_grid_mirai","text":"mirai::daemons set parallel backend mirai::mirai_map parallelize work grid. details terminology mirai package, refer mirai::mirai. function assumes users one raster file sizable spatially distributed target locations. thread process nearest integer $|N_g| / |N_t|$ grids $|N_g|$ denotes number grids $|N_t|$ denotes number threads.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_grid_mirai.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelize spatial computation over the computational grids — par_grid_mirai","text":"","code":"par_grid_mirai(grids, fun_dist, ..., pad_y = FALSE, .debug = TRUE)"},{"path":"https://docs.ropensci.org/chopin/reference/par_grid_mirai.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelize spatial computation over the computational grids — par_grid_mirai","text":"grids List two sf/SpatVector objects. Computational grids. takes strict assumption grid input output `par_pad_grid“. fun_dist sf, terra chopin functions. function x y arguments. ... Arguments passed argument fun_dist. pad_y logical(1). Whether filter y padded grid. TRUE x values calculated. Default FALSE. reverse case, like terra::extent exactextractr::exact_extract, raster (x) extent set padded grid. .debug logical(1). Default FALSE. Otherwise, unit computation fails, error message CGRIDID value error occurred included output.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_grid_mirai.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallelize spatial computation over the computational grids — par_grid_mirai","text":"data.frame object computation results. entries results, consult documentation function put fun_dist argument.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_grid_mirai.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Parallelize spatial computation over the computational grids — par_grid_mirai","text":"dynamic dots (...), fun_dist arguments include x y sf/terra class objects file paths accepted. Virtually sf/terra functions accept two arguments can put fun_dist, please advised spatial operations necessarily give exact result done single-thread. example, distance calculated function may return lower value actual computational region reduced. case especially target features spatially sparsely distributed.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/par_grid_mirai.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parallelize spatial computation over the computational grids — par_grid_mirai","text":"Insang Song geoissong@gmail.com","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_grid_mirai.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parallelize spatial computation over the computational grids — par_grid_mirai","text":"","code":"library(sf) library(mirai) daemons(4, dispatcher = \"process\") #> [1] 4 ncpath <- system.file(\"shape/nc.shp\", package = \"sf\") ncpoly <- sf::st_read(ncpath) #> Reading layer `nc' from data source  #>   `/usr/local/lib/R/site-library/sf/shape/nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 # sf object ncpnts <-   readRDS(     system.file(\"extdata/nc_random_point.rds\", package = \"chopin\")   ) # file path ncelev <-     system.file(\"extdata/nc_srtm15_otm.tif\", package = \"chopin\")  nccompreg <-   chopin::par_pad_grid(     input = ncpnts,     mode = \"grid\",     nx = 4L,     ny = 2L,     padding = 5e3L   ) #> Switch sf class to terra... #> Switch terra class to sf... res <-   par_grid_mirai(     grids = nccompreg,     fun_dist = extract_at,     x = ncelev,     y = ncpnts,     qsegs = 90L,     radius = 5e3L,     id = \"pid\"   ) #> ℹ Input is not a character. #> ■■■■■                             12% | ETA:  1m #> ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■  100% | ETA:  0s mirai::daemons(0L) #> [1] 0"},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelize spatial computation by hierarchy in input data — par_hierarchy","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy","text":"\"Hierarchy\" refers system, divides entire study region multiple subregions. oftentimes reflected area code system (e.g., FIPS US Census geographies Nomenclature Territorial Units Statistics (NUTS), etc.). future::multisession, future::multicore, future::cluster, future.mirai::mirai_multisession future::plan parallelize work splitting lower level features several higher level feature group. details terminology future package, please refer future::plan documentation. thread process number lower level features higher level feature. Please advised accessing file simultaneously multiple processes may result errors.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy","text":"","code":"par_hierarchy(   regions,   regions_id = NULL,   length_left = NULL,   pad = 0,   pad_y = FALSE,   fun_dist,   ...,   .debug = FALSE )"},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy","text":"regions sf/SpatVector object. Computational regions. polygons accepted. regions_id character(1). Name unique ID field regions. regions split common level value. length_left integer(1). Length first characters regions_id values. Default NULL, manipulate regions_id values. number characters consistent (example, numerics), function alert user. pad numeric(1). Padding distance subregion defined regions_id trimmed regions_id values. linear unit coordinate system. Default 0, means subregion used . value greater 0, subregion buffered value. padding distance applied x (pad_y = FALSE) y (pad_y = TRUE) filter data. pad_y logical(1). Whether filter y padded grid. TRUE x values calculated. Default FALSE. reverse case, like terra::extent exactextractr::exact_extract, raster (x) scoped padded grid. fun_dist sf, terra, chopin functions. function x y arguments. ... Arguments passed argument fun_dist. .debug logical(1). Default FALSE unit computation fails, error message regions_id value error occurred included output.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy","text":"data.frame object computation results. entries results, consult function used fun_dist argument.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy","text":"dynamic dots (...), fun_dist arguments include x y sf/terra class objects file paths accepted. Hierarchy interpreted regions_id argument first. regions_id assumed field name x y argument object. expected regions represents higher level boundaries x y fun_dist lower level boundaries. However, case, trim argument, function generate higher level codes regions_id extracting left-t Whether x y searched determined pad_y value. pad_y = TRUE make function attempt find regions_id x, whereas pad_y = FALSE look regions_id y. regions_id exist x y, function utilize spatial relationship (intersects) filter data. Note dispatching computation subregions based spatial relationship may lead slight discrepancy result. example, higher lower level features perfectly aligned, may features included duplicated subregions. function alert user spatial relation- ship used filter data.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy","text":"Virtually sf/terra functions accept two arguments can put fun_dist, please advised spatial operations necessarily give exact result done single thread. example, distance calculated function may return lower value actual computational region reduced. case especially target features spatially sparsely distributed.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy","text":"Insang Song geoissong@gmail.com","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy","text":"","code":"library(terra) #> terra 1.8.10 library(sf) library(future) library(future.mirai) options(sf_use_s2 = FALSE) future::plan(future.mirai::mirai_multisession, workers = 2)  ncpath <- system.file(\"extdata/nc_hierarchy.gpkg\", package = \"chopin\") nccnty <- sf::st_read(ncpath, layer = \"county\") #> Reading layer `county' from data source  #>   `/usr/local/lib/R/site-library/chopin/extdata/nc_hierarchy.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 100 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 #> Projected CRS: NAD83 / Conus Albers nctrct <- sf::st_read(ncpath, layer = \"tracts\") #> Reading layer `tracts' from data source  #>   `/usr/local/lib/R/site-library/chopin/extdata/nc_hierarchy.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 2672 features and 1 field #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 #> Projected CRS: NAD83 / Conus Albers ncelev <-   system.file(\"extdata/nc_srtm15_otm.tif\", package = \"chopin\")  ncsamp <-   sf::st_sample(     nccnty,     size = 1e4L   ) # sfc to sf ncsamp <- sf::st_as_sf(ncsamp) # assign ID ncsamp$kid <- sprintf(\"K-%05d\", seq_len(nrow(ncsamp))) res <-   par_hierarchy(     regions = nccnty,     regions_id = \"GEOID\",     fun_dist = extract_at,     y = nctrct,     x = ncelev,     id = \"GEOID\",     func = \"mean\"   ) #> ℹ Input is not a character. #> ℹ GEOID is used to stratify the process. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37037 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37001 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37057 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37069 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37155 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37109 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37027 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37063 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37145 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37115 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37151 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37131 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37013 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37159 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37051 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37153 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37093 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37025 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37029 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37169 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37031 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37005 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37139 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37193 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37003 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37083 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37163 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37189 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37173 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37011 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37045 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37125 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37067 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37077 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37185 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37137 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37033 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37107 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37075 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37073 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37161 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37187 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37007 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37135 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37049 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37195 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37061 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37087 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37081 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37099 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37097 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37091 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37149 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37165 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37085 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37105 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37017 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37039 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37035 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37177 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37113 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37143 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37095 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37071 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37101 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37015 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37167 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37079 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37129 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37147 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37141 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37179 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37121 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37133 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37065 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37119 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37199 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37197 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37023 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37191 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37059 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37111 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37183 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37053 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37103 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37041 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37021 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37157 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37117 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37089 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37127 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37009 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37019 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37123 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37181 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37175 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37171 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37043 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37055 is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at 37047 is dispatched."},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy_mirai.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelize spatial computation by hierarchy in input data — par_hierarchy_mirai","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy_mirai","text":"\"Hierarchy\" refers system, divides entire study region multiple subregions. usually reflected area code system (e.g., FIPS US Census geographies Nomenclature Territorial Units Statistics (NUTS), etc.). mirai::daemons set parallel backend mirai::mirai_map work splitting lower level features several higher level feature group. details terminology mirai package, refer mirai::mirai. thread process number lower level features higher level feature. Please advised accessing file simultaneously multiple processes may result errors.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy_mirai.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy_mirai","text":"","code":"par_hierarchy_mirai(   regions,   regions_id = NULL,   length_left = NULL,   pad = 0,   pad_y = FALSE,   fun_dist,   ...,   .debug = TRUE )"},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy_mirai.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy_mirai","text":"regions sf/SpatVector object. Computational regions. polygons accepted. regions_id character(1). Name unique ID field regions. regions split common level value. length_left integer(1). Length first characters regions_id values. Default NULL, manipulate regions_id values. number characters consistent (example, numerics), function alert user. pad numeric(1). Padding distance subregion defined regions_id trimmed regions_id values. linear unit coordinate system. Default 0, means subregion used . value greater 0, subregion buffered value. padding distance applied x (pad_y = FALSE) y (pad_y = TRUE) filter data. pad_y logical(1). Whether filter y padded grid. TRUE x values calculated. Default FALSE. reverse case, like terra::extent exactextractr::exact_extract, raster (x) scoped padded grid. fun_dist sf, terra, chopin functions. function x y arguments. ... Arguments passed argument fun_dist. .debug logical(1). Default FALSE unit computation fails, error message regions_id value error occurred included output.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy_mirai.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy_mirai","text":"data.frame object computation results. entries results, consult function used fun_dist argument.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy_mirai.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy_mirai","text":"dynamic dots (...), fun_dist arguments include x y sf/terra class objects file paths accepted. Hierarchy interpreted regions_id argument first. regions_id assumed field name x y argument object. expected regions represents higher level boundaries x y fun_dist lower level boundaries. However, case, trim argument, function generate higher level codes regions_id extracting code left end (controlled length_left). Whether x y searched determined pad_y value. pad_y = TRUE make function attempt find regions_id x, whereas pad_y = FALSE look regions_id y. regions_id exist x y, function utilize spatial relationship (intersects) filter data. Note dispatching computation subregions based spatial relationship may lead slight discrepancy result. example, higher lower level features perfectly aligned, may features included duplicated subregions. function alert user spatial relation- ship used filter data.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy_mirai.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy_mirai","text":"Virtually sf/terra functions accept two arguments can put fun_dist, please advised spatial operations necessarily give exact result done single thread. example, distance calculated function may return lower value actual computational region reduced. case especially target features spatially sparsely distributed.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy_mirai.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy_mirai","text":"Insang Song geoissong@gmail.com","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_hierarchy_mirai.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parallelize spatial computation by hierarchy in input data — par_hierarchy_mirai","text":"","code":"library(terra) library(sf) library(mirai) options(sf_use_s2 = FALSE) mirai::daemons(4, dispatcher = \"process\") #> [1] 4  ncpath <- system.file(\"extdata/nc_hierarchy.gpkg\", package = \"chopin\") nccnty <- sf::st_read(ncpath, layer = \"county\") #> Reading layer `county' from data source  #>   `/usr/local/lib/R/site-library/chopin/extdata/nc_hierarchy.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 100 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 #> Projected CRS: NAD83 / Conus Albers nctrct <- sf::st_read(ncpath, layer = \"tracts\") #> Reading layer `tracts' from data source  #>   `/usr/local/lib/R/site-library/chopin/extdata/nc_hierarchy.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 2672 features and 1 field #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 #> Projected CRS: NAD83 / Conus Albers ncelev <-   system.file(\"extdata/nc_srtm15_otm.tif\", package = \"chopin\")  ncsamp <-   sf::st_sample(     nccnty,     size = 1e4L   ) # sfc to sf ncsamp <- sf::st_as_sf(ncsamp) # assign ID ncsamp$kid <- sprintf(\"K-%05d\", seq_len(nrow(ncsamp))) res <-   par_hierarchy_mirai(     regions = nccnty,     regions_id = \"GEOID\",     fun_dist = extract_at,     y = nctrct,     x = ncelev,     id = \"GEOID\",     func = \"mean\",     .debug = TRUE   ) #> ℹ Input is not a character. #> ℹ GEOID is used to stratify the process. #> ■                                  1% | ETA: 10m #> ■■■■■■■■                          24% | ETA: 26s #> ■■■■■■■■■■■■■■■■■■■■■■■■■■■       87% | ETA:  2s #> ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■  100% | ETA:  0s mirai::daemons(0L) #> [1] 0"},{"path":"https://docs.ropensci.org/chopin/reference/par_make_balanced.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate groups based on balanced clustering — par_make_balanced","title":"Generate groups based on balanced clustering — par_make_balanced","text":"balancing computational loads, function uses anticlust package cluster input points. number clusters determined num_cluster argument. cluster equal number points. Grids generated based cluster extents. lower level, function uses terra::distance() function calculate Euclidean distance points.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_make_balanced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate groups based on balanced clustering — par_make_balanced","text":"","code":"par_make_balanced(points_in = NULL, n_clusters = NULL)"},{"path":"https://docs.ropensci.org/chopin/reference/par_make_balanced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate groups based on balanced clustering — par_make_balanced","text":"points_in sf SpatVector object. Target points computation. n_clusters integer(1). number clusters.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_make_balanced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate groups based on balanced clustering — par_make_balanced","text":"SpatVector object field \"CGRIDID\".","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_make_balanced.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate groups based on balanced clustering — par_make_balanced","text":"function two-dimensional points. results irregular grids without overlapping parts.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_make_balanced.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate groups based on balanced clustering — par_make_balanced","text":"Insang Song","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_make_balanced.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate groups based on balanced clustering — par_make_balanced","text":"","code":"if (FALSE) { # \\dontrun{ library(terra) library(anticlust) data(ncpoints, package = \"chopin\")  ncp <- terra::vect(   ncpoints, geom = c(\"X\", \"Y\"),   keepgeom = FALSE, crs = \"EPSG:5070\" )  # 2,304 points / 12 = 192 points per cluster ncpbal <- par_make_balanced(ncp, 12) ncpbal } # }"},{"path":"https://docs.ropensci.org/chopin/reference/par_make_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate grid polygons — par_make_grid","title":"Generate grid polygons — par_make_grid","text":"Returns sf object includes x- y- index using two inputs ncutsx ncutsy, x- y-directional splits, respectively.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_make_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate grid polygons — par_make_grid","text":"","code":"par_make_grid(points_in = NULL, ncutsx = NULL, ncutsy = NULL)"},{"path":"https://docs.ropensci.org/chopin/reference/par_make_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate grid polygons — par_make_grid","text":"points_in sf SpatVector object. Target points computation. character(1) file path also acceptable. ncutsx integer(1). number splits along x-axis. ncutsy integer(1). number splits along y-axis.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_make_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate grid polygons — par_make_grid","text":"sf SpatVector object computation grids unique grid id (CGRIDID).","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_make_grid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generate grid polygons — par_make_grid","text":"Grids generated based extent points_in first, exhaustive grids filtered intersection points_in. Thus, number generated grids may smaller ncutsx * ncutsy.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/par_make_grid.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate grid polygons — par_make_grid","text":"Insang Song","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_make_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate grid polygons — par_make_grid","text":"","code":"if (FALSE) { # \\dontrun{ library(sf) library(terra) options(sf_use_s2 = FALSE)  nc_path <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc <- terra::vect(nc_path) nc_rp <- terra::spatSample(nc, 1000) nc_gr <- par_make_grid(nc_rp, 10L, 6L)  plot(nc_rp) plot(nc_gr, add = TRUE) } # }"},{"path":"https://docs.ropensci.org/chopin/reference/par_merge_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Merge adjacent grid polygons with given rules — par_merge_grid","title":"Merge adjacent grid polygons with given rules — par_merge_grid","text":"Merge boundary-sharing (\"Rook\" contiguity) grids fewer target features threshold. function strongly assumes input returned par_make_grid, \"CGRIDID\" unique id field.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_merge_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Merge adjacent grid polygons with given rules — par_merge_grid","text":"","code":"par_merge_grid(   points_in = NULL,   grid_in = NULL,   grid_min_features = NULL,   merge_max = 4L )"},{"path":"https://docs.ropensci.org/chopin/reference/par_merge_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Merge adjacent grid polygons with given rules — par_merge_grid","text":"points_in sf SpatVector object. Target points computation. grid_in sf SpatVector object. grid generated internal function par_make_grid. grid_min_features integer(1). Threshold merge adjacent grids. merge_max integer(1). Maximum number grids merge per merged set. Default 4. example, number grids merge 20 merge_max 10, function split 20 grids two sets 10 grids.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_merge_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Merge adjacent grid polygons with given rules — par_merge_grid","text":"sf SpatVector object computation grids.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_merge_grid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Merge adjacent grid polygons with given rules — par_merge_grid","text":"function work properly grid_in one million grids.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_merge_grid.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Merge adjacent grid polygons with given rules — par_merge_grid","text":"Polsby DD, Popper FJ. (1991). Third Criterion: Compactness Procedural Safeguard Partisan Gerrymandering. Yale Law & Policy Review, 9(2), 301–353.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/par_merge_grid.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Merge adjacent grid polygons with given rules — par_merge_grid","text":"Insang Song","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_merge_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Merge adjacent grid polygons with given rules — par_merge_grid","text":"","code":"library(sf) library(igraph) #>  #> Attaching package: ‘igraph’ #> The following objects are masked from ‘package:terra’: #>  #>     blocks, compare, union #> The following objects are masked from ‘package:future’: #>  #>     %->%, %<-% #> The following objects are masked from ‘package:stats’: #>  #>     decompose, spectrum #> The following object is masked from ‘package:base’: #>  #>     union library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:igraph’: #>  #>     as_data_frame, groups, union #> The following objects are masked from ‘package:terra’: #>  #>     intersect, union #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union library(spatstat.random) #> Loading required package: spatstat.data #> Loading required package: spatstat.univar #> spatstat.univar 3.1-1 #> Loading required package: spatstat.geom #> spatstat.geom 3.3-5 #>  #> Attaching package: ‘spatstat.geom’ #> The following objects are masked from ‘package:igraph’: #>  #>     diameter, edges, is.connected, vertices #> The following objects are masked from ‘package:terra’: #>  #>     area, delaunay, is.empty, rescale, rotate, shift, where.max, #>     where.min #> spatstat.random 3.3-2 options(sf_use_s2 = FALSE)  dg <- sf::st_as_sfc(st_bbox(c(xmin = 0, ymin = 0, xmax = 8e5, ymax = 6e5))) sf::st_crs(dg) <- 5070 dgs <- sf::st_as_sf(st_make_grid(dg, n = c(20, 15))) dgs$CGRIDID <- seq(1, nrow(dgs))  dg_sample <- sf::st_sample(dg, kappa = 5e-9, mu = 15, scale = 15000, type = \"Thomas\") sf::st_crs(dg_sample) <- sf::st_crs(dg) dg_merged <- par_merge_grid(sf::st_as_sf(dg_sample), dgs, 100) #> ℹ The merged polygons have too complex shapes. #> Increase threshold or use the original grids.  plot(sf::st_geometry(dg_merged))"},{"path":"https://docs.ropensci.org/chopin/reference/par_multirasters.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelize spatial computation over multiple raster files — par_multirasters","title":"Parallelize spatial computation over multiple raster files — par_multirasters","text":"Large raster files usually exceed memory capacity size. function can helpful process heterogenous raster files homogeneous summary functions. Heterogenous raster files refer rasters different spatial extents resolutions. Cropping large raster small subset even consumes lot memory adds processing time. function leverages terra SpatRaster distribute computation jobs multiple threads. assumed users multiple large raster files disk, file path assigned thread. thread directly read raster values disk using C++ pointers operate terra functions. use, strongly recommended use vector data small confined spatial extent computation avoid --memory error. y argument fun_dist used -. means preprocessing subsetting applied. Please aware spatial extent size inputs.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_multirasters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelize spatial computation over multiple raster files — par_multirasters","text":"","code":"par_multirasters(filenames, fun_dist, ..., .debug = FALSE)"},{"path":"https://docs.ropensci.org/chopin/reference/par_multirasters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelize spatial computation over multiple raster files — par_multirasters","text":"filenames character. vector list full file paths raster files. n total number raster files. fun_dist terra chopin functions accept SpatRaster object argument. particular, x y arguments present x SpatRaster. ... Arguments passed argument fun_dist. .debug logical(1). Default FALSE. TRUE unit computation fails, error message file path error occurred included output.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_multirasters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallelize spatial computation over multiple raster files — par_multirasters","text":"data.frame object computation results. entries results, consult function used fun_dist argument.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/par_multirasters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parallelize spatial computation over multiple raster files — par_multirasters","text":"Insang Song geoissong@gmail.com","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_multirasters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parallelize spatial computation over multiple raster files — par_multirasters","text":"","code":"library(terra) library(sf) library(future) library(future.mirai) sf::sf_use_s2(FALSE) future::plan(future.mirai::mirai_multisession, workers = 2)  ncpath <- system.file(\"extdata/nc_hierarchy.gpkg\", package = \"chopin\") nccnty <- sf::st_read(ncpath, layer = \"county\") #> Reading layer `county' from data source  #>   `/usr/local/lib/R/site-library/chopin/extdata/nc_hierarchy.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 100 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 #> Projected CRS: NAD83 / Conus Albers ncelev <-   system.file(\"extdata/nc_srtm15_otm.tif\", package = \"chopin\") ncelevras <- terra::rast(ncelev)  tdir <- tempdir(check = TRUE) terra::writeRaster(ncelevras, file.path(tdir, \"test1.tif\"), overwrite = TRUE) terra::writeRaster(ncelevras, file.path(tdir, \"test2.tif\"), overwrite = TRUE) testfiles <- list.files(tdir, pattern = \"tif$\", full.names = TRUE)  res <- par_multirasters(   filenames = testfiles,   fun_dist = extract_at,   x = ncelev,   y = nccnty,   id = \"GEOID\",   func = \"mean\" ) #> ℹ Input is not a character. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at /tmp/Rtmp2t0CTW/test1.tif is dispatched. #> Input is a character. Attempt to read it with terra::rast... #> ℹ Your input function at /tmp/Rtmp2t0CTW/test2.tif is dispatched."},{"path":"https://docs.ropensci.org/chopin/reference/par_multirasters_mirai.html","id":null,"dir":"Reference","previous_headings":"","what":"Parallelize spatial computation over multiple raster files — par_multirasters_mirai","title":"Parallelize spatial computation over multiple raster files — par_multirasters_mirai","text":"Large raster files usually exceed memory capacity size. function can helpful process heterogenous raster files homogeneous summary functions. Heterogenous raster files refer rasters different spatial extents resolutions. Cropping large raster small subset even consumes lot memory adds processing time. function leverages terra SpatRaster distribute computation jobs multiple threads. assumed users multiple large raster files disk, file path assigned thread. thread directly read raster values disk using C++ pointers operate terra functions. use, strongly recommended use vector data small confined spatial extent computation avoid --memory error. y argument fun_dist used -. means preprocessing subsetting applied. Please aware spatial extent size inputs.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_multirasters_mirai.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parallelize spatial computation over multiple raster files — par_multirasters_mirai","text":"","code":"par_multirasters_mirai(filenames, fun_dist, ..., .debug = TRUE)"},{"path":"https://docs.ropensci.org/chopin/reference/par_multirasters_mirai.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parallelize spatial computation over multiple raster files — par_multirasters_mirai","text":"filenames character. vector list full file paths raster files. n total number raster files. fun_dist terra chopin functions accept SpatRaster object argument. particular, x y arguments present x SpatRaster. ... Arguments passed argument fun_dist. .debug logical(1). Default FALSE. TRUE unit computation fails, error message file path error occurred included output.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_multirasters_mirai.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parallelize spatial computation over multiple raster files — par_multirasters_mirai","text":"data.frame object computation results. entries results, consult function used fun_dist argument.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/par_multirasters_mirai.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Parallelize spatial computation over multiple raster files — par_multirasters_mirai","text":"Insang Song geoissong@gmail.com","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_multirasters_mirai.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parallelize spatial computation over multiple raster files — par_multirasters_mirai","text":"","code":"library(terra) library(sf) library(mirai) sf::sf_use_s2(FALSE) mirai::daemons(4, dispatcher = \"process\") #> [1] 4  ncpath <- system.file(\"extdata/nc_hierarchy.gpkg\", package = \"chopin\") nccnty <- sf::st_read(ncpath, layer = \"county\") #> Reading layer `county' from data source  #>   `/usr/local/lib/R/site-library/chopin/extdata/nc_hierarchy.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 100 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054155 ymin: 1341756 xmax: 1838923 ymax: 1690176 #> Projected CRS: NAD83 / Conus Albers ncelev <-   system.file(\"extdata/nc_srtm15_otm.tif\", package = \"chopin\") ncelevras <- terra::rast(ncelev)  tdir <- tempdir(check = TRUE) terra::writeRaster(ncelevras, file.path(tdir, \"test1.tif\"), overwrite = TRUE) terra::writeRaster(ncelevras, file.path(tdir, \"test2.tif\"), overwrite = TRUE) testfiles <- list.files(tdir, pattern = \"tif$\", full.names = TRUE)  res <- par_multirasters_mirai(   filenames = testfiles,   fun_dist = extract_at,   x = ncelev,   y = nccnty,   id = \"GEOID\",   func = \"mean\" ) #> ℹ Input is not a character. #> ■■■■■■■■■■■■■■■■                  50% | ETA:  5s #> ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■  100% | ETA:  0s mirai::daemons(0L) #> [1] 0"},{"path":"https://docs.ropensci.org/chopin/reference/par_pad_balanced.html","id":null,"dir":"Reference","previous_headings":"","what":"Extension of par_make_balanced for padded grids — par_pad_balanced","title":"Extension of par_make_balanced for padded grids — par_pad_balanced","text":"function utilizes anticlust::balanced_clustering() split input equal size subgroups transform data compatible output par_pad_grid, set padded grids extent input point subsets (recorded field named \"CGRIDID\") generated input points.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_pad_balanced.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extension of par_make_balanced for padded grids — par_pad_balanced","text":"","code":"par_pad_balanced(points_in = NULL, ngroups, padding)"},{"path":"https://docs.ropensci.org/chopin/reference/par_pad_balanced.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extension of par_make_balanced for padded grids — par_pad_balanced","text":"points_in sf SpatVector object. Point geometries. Default NULL. ngroups integer(1). number groups. padding numeric(1). extrusion factor make buffer clip actual datasets. Depending length unit CRS input.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_pad_balanced.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extension of par_make_balanced for padded grids — par_pad_balanced","text":"list two, original: exhaustive non-overlapping grid polygons class input padded: square buffer polygon original. Used computation.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/par_pad_balanced.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extension of par_make_balanced for padded grids — par_pad_balanced","text":"Insang Song","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_pad_balanced.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extension of par_make_balanced for padded grids — par_pad_balanced","text":"","code":"library(terra) library(sf) options(sf_use_s2 = FALSE)  ncpath <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc <- terra::vect(ncpath) nc_rp <- terra::spatSample(nc, 1000)  nc_gr <- par_pad_balanced(nc_rp, 10L, 1000) nc_gr #> $original #>  class       : SpatVector  #>  geometry    : points  #>  dimensions  : 1000, 15  (geometries, attributes) #>  extent      : -84.18474, -75.673, 33.92827, 36.58469  (xmin, xmax, ymin, ymax) #>  coord. ref. : lon/lat NAD27 (EPSG:4267)  #>  names       :  AREA PERIMETER CNTY_ CNTY_ID     NAME  FIPS    FIPSNO CRESS_ID #>  type        : <num>     <num> <num>   <num>    <chr> <chr>     <num>    <int> #>  values      : 0.141     2.316  2013    2013    Swain 37173 3.717e+04       87 #>                0.109     1.325  1841    1841   Person 37145 3.714e+04       73 #>                0.125     2.868  2156    2156 Carteret 37031 3.703e+04       16 #>  BIR74 SID74 (and 5 more) #>  <num> <num>              #>    675     3              #>   1556     4              #>   2414     5              #>  #> $padded #>  class       : SpatVector  #>  geometry    : polygons  #>  dimensions  : 10, 1  (geometries, attributes) #>  extent      : -1084.185, 924.327, -966.0717, 1036.585  (xmin, xmax, ymin, ymax) #>  coord. ref. :   #>  names       : CGRIDID #>  type        :   <num> #>  values      :       1 #>                      2 #>                      3 #>"},{"path":"https://docs.ropensci.org/chopin/reference/par_pad_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Get a set of computational grids — par_pad_grid","title":"Get a set of computational grids — par_pad_grid","text":"Using input points, bounding box split predefined numbers columns rows. grid buffered radius.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_pad_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get a set of computational grids — par_pad_grid","text":"","code":"par_pad_grid(   input,   mode = c(\"grid\", \"grid_advanced\", \"grid_quantile\"),   nx = 10L,   ny = 10L,   grid_min_features = 30L,   padding = NULL,   unit = NULL,   quantiles = NULL,   merge_max = NULL,   return_wkt = FALSE,   ... )"},{"path":"https://docs.ropensci.org/chopin/reference/par_pad_grid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get a set of computational grids — par_pad_grid","text":"input sf Spat* object. mode character(1). Mode region construction. One \"grid\" (simple grid regardless number features grid) \"grid_advanced\" (merging adjacent grids smaller number features grid_min_features). argument grid_min_features specified. \"grid_quantile\" (x y quantiles): argument quantiles specified. nx integer(1). number grids along x-axis. ny integer(1). number grids along y-axis. grid_min_features integer(1). threshold merging adjacent grids padding numeric(1). extrusion factor make buffer clip actual datasets. Depending length unit CRS input. unit character(1). length unit padding (optional). units::set_units used padding sf object used. See link list acceptable unit forms. quantiles numeric. Quantiles grid_quantile mode. merge_max integer(1). Maximum number grids merge per merged set. return_wkt logical(1). Return WKT format. TRUE, return value list two WKT strings. ... arguments passed internal function","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_pad_grid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get a set of computational grids — par_pad_grid","text":"list two, original: exhaustive (filling completely) non-overlapping grid polygons class input padded: square buffer polygon original. Used computation.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/par_pad_grid.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get a set of computational grids — par_pad_grid","text":"Insang Song","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_pad_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get a set of computational grids — par_pad_grid","text":"","code":"# data library(sf) options(sf_use_s2 = FALSE) ncpath <- system.file(\"shape/nc.shp\", package = \"sf\") nc <- read_sf(ncpath) nc <- st_transform(nc, \"EPSG:5070\")  # run: nx and ny should strictly be integers nc_comp_region <-   par_pad_grid(     nc,     mode = \"grid\",     nx = 4L, ny = 2L,     padding = 10000) #> Switch sf class to terra... #> Switch terra class to sf... par(mfcol = c(1, 2)) plot(nc_comp_region$original$geometry) plot(nc_comp_region$padded$geometry)   nc_comp_region_wkt <-   par_pad_grid(     nc,     mode = \"grid\",     nx = 4L, ny = 2L,     padding = 10000,     return_wkt = TRUE) #> Switch sf class to terra... #> Switch terra class to sf... nc_comp_region_wkt$original #> [1] \"POLYGON ((1054293 1348021, 1249094 1348021, 1249094 1518623, 1054293 1518623, 1054293 1348021))\" #> [2] \"POLYGON ((1249094 1348021, 1443895 1348021, 1443895 1518623, 1249094 1518623, 1249094 1348021))\" #> [3] \"POLYGON ((1443895 1348021, 1638695 1348021, 1638695 1518623, 1443895 1518623, 1443895 1348021))\" #> [4] \"POLYGON ((1638695 1348021, 1833496 1348021, 1833496 1518623, 1638695 1518623, 1638695 1348021))\" #> [5] \"POLYGON ((1054293 1518623, 1249094 1518623, 1249094 1689226, 1054293 1689226, 1054293 1518623))\" #> [6] \"POLYGON ((1249094 1518623, 1443895 1518623, 1443895 1689226, 1249094 1689226, 1249094 1518623))\" #> [7] \"POLYGON ((1443895 1518623, 1638695 1518623, 1638695 1689226, 1443895 1689226, 1443895 1518623))\" #> [8] \"POLYGON ((1638695 1518623, 1833496 1518623, 1833496 1689226, 1638695 1689226, 1638695 1518623))\" nc_comp_region_wkt$padded #> [1] \"POLYGON ((1044293 1338021, 1044293 1528623, 1259094 1528623, 1259094 1338021, 1044293 1338021))\" #> [2] \"POLYGON ((1239094 1338021, 1239094 1528623, 1453895 1528623, 1453895 1338021, 1239094 1338021))\" #> [3] \"POLYGON ((1433895 1338021, 1433895 1528623, 1648695 1528623, 1648695 1338021, 1433895 1338021))\" #> [4] \"POLYGON ((1628695 1338021, 1628695 1528623, 1843496 1528623, 1843496 1338021, 1628695 1338021))\" #> [5] \"POLYGON ((1044293 1508623, 1044293 1699226, 1259094 1699226, 1259094 1508623, 1044293 1508623))\" #> [6] \"POLYGON ((1239094 1508623, 1239094 1699226, 1453895 1699226, 1453895 1508623, 1239094 1508623))\" #> [7] \"POLYGON ((1433895 1508623, 1433895 1699226, 1648695 1699226, 1648695 1508623, 1433895 1508623))\" #> [8] \"POLYGON ((1628695 1508623, 1628695 1699226, 1843496 1699226, 1843496 1508623, 1628695 1508623))\""},{"path":"https://docs.ropensci.org/chopin/reference/par_split_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Split grid list to a nested list of row-wise data frames — par_split_list","title":"Split grid list to a nested list of row-wise data frames — par_split_list","text":"Split grid list nested list row-wise data frames","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_split_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Split grid list to a nested list of row-wise data frames — par_split_list","text":"","code":"par_split_list(gridlist)"},{"path":"https://docs.ropensci.org/chopin/reference/par_split_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Split grid list to a nested list of row-wise data frames — par_split_list","text":"gridlist list. Output par_pad_grid par_pad_balanced","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_split_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Split grid list to a nested list of row-wise data frames — par_split_list","text":"nested list data frames WKT strings.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/par_split_list.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Split grid list to a nested list of row-wise data frames — par_split_list","text":"input data frame, function return list two data frames: original padded. input WKT vector, function return list two WKT strings: original padded.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/par_split_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Split grid list to a nested list of row-wise data frames — par_split_list","text":"","code":"library(sf) library(terra) options(sf_use_s2 = FALSE)  ncpath <- system.file(\"shape/nc.shp\", package = \"sf\") nc <- read_sf(ncpath) nc <- st_transform(nc, \"EPSG:5070\") nc_comp_region <-   par_pad_grid(     nc,     mode = \"grid\",     nx = 4L, ny = 2L,     padding = 10000) #> Switch sf class to terra... #> Switch terra class to sf... par_split_list(nc_comp_region) #> [[1]] #> [[1]]$original #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054293 ymin: 1348021 xmax: 1249094 ymax: 1518623 #> Projected CRS: NAD83 / Conus Albers #>                         geometry CGRIDID #> 1 POLYGON ((1054293 1348021, ...       1 #>  #> [[1]]$padded #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1044293 ymin: 1338021 xmax: 1259094 ymax: 1528623 #> Projected CRS: NAD83 / Conus Albers #>   CGRIDID                       geometry #> 1       1 POLYGON ((1044293 1338021, ... #>  #>  #> [[2]] #> [[2]]$original #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1249094 ymin: 1348021 xmax: 1443895 ymax: 1518623 #> Projected CRS: NAD83 / Conus Albers #>                         geometry CGRIDID #> 2 POLYGON ((1249094 1348021, ...       2 #>  #> [[2]]$padded #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1239094 ymin: 1338021 xmax: 1453895 ymax: 1528623 #> Projected CRS: NAD83 / Conus Albers #>   CGRIDID                       geometry #> 2       2 POLYGON ((1239094 1338021, ... #>  #>  #> [[3]] #> [[3]]$original #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1443895 ymin: 1348021 xmax: 1638695 ymax: 1518623 #> Projected CRS: NAD83 / Conus Albers #>                         geometry CGRIDID #> 3 POLYGON ((1443895 1348021, ...       3 #>  #> [[3]]$padded #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1433895 ymin: 1338021 xmax: 1648695 ymax: 1528623 #> Projected CRS: NAD83 / Conus Albers #>   CGRIDID                       geometry #> 3       3 POLYGON ((1433895 1338021, ... #>  #>  #> [[4]] #> [[4]]$original #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1638695 ymin: 1348021 xmax: 1833496 ymax: 1518623 #> Projected CRS: NAD83 / Conus Albers #>                         geometry CGRIDID #> 4 POLYGON ((1638695 1348021, ...       4 #>  #> [[4]]$padded #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1628695 ymin: 1338021 xmax: 1843496 ymax: 1528623 #> Projected CRS: NAD83 / Conus Albers #>   CGRIDID                       geometry #> 4       4 POLYGON ((1628695 1338021, ... #>  #>  #> [[5]] #> [[5]]$original #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1054293 ymin: 1518623 xmax: 1249094 ymax: 1689226 #> Projected CRS: NAD83 / Conus Albers #>                         geometry CGRIDID #> 5 POLYGON ((1054293 1518623, ...       5 #>  #> [[5]]$padded #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1044293 ymin: 1508623 xmax: 1259094 ymax: 1699226 #> Projected CRS: NAD83 / Conus Albers #>   CGRIDID                       geometry #> 5       5 POLYGON ((1044293 1508623, ... #>  #>  #> [[6]] #> [[6]]$original #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1249094 ymin: 1518623 xmax: 1443895 ymax: 1689226 #> Projected CRS: NAD83 / Conus Albers #>                         geometry CGRIDID #> 6 POLYGON ((1249094 1518623, ...       6 #>  #> [[6]]$padded #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1239094 ymin: 1508623 xmax: 1453895 ymax: 1699226 #> Projected CRS: NAD83 / Conus Albers #>   CGRIDID                       geometry #> 6       6 POLYGON ((1239094 1508623, ... #>  #>  #> [[7]] #> [[7]]$original #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1443895 ymin: 1518623 xmax: 1638695 ymax: 1689226 #> Projected CRS: NAD83 / Conus Albers #>                         geometry CGRIDID #> 7 POLYGON ((1443895 1518623, ...       7 #>  #> [[7]]$padded #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1433895 ymin: 1508623 xmax: 1648695 ymax: 1699226 #> Projected CRS: NAD83 / Conus Albers #>   CGRIDID                       geometry #> 7       7 POLYGON ((1433895 1508623, ... #>  #>  #> [[8]] #> [[8]]$original #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1638695 ymin: 1518623 xmax: 1833496 ymax: 1689226 #> Projected CRS: NAD83 / Conus Albers #>                         geometry CGRIDID #> 8 POLYGON ((1638695 1518623, ...       8 #>  #> [[8]]$padded #> Simple feature collection with 1 feature and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 1628695 ymin: 1508623 xmax: 1843496 ymax: 1699226 #> Projected CRS: NAD83 / Conus Albers #>   CGRIDID                       geometry #> 8       8 POLYGON ((1628695 1508623, ... #>  #>"},{"path":"https://docs.ropensci.org/chopin/reference/prediction_grid.html","id":null,"dir":"Reference","previous_headings":"","what":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"Regular grid points mainland United States 1km spatial resolution","code":""},{"path":"https://docs.ropensci.org/chopin/reference/prediction_grid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"","code":"prediction_grid"},{"path":"https://docs.ropensci.org/chopin/reference/prediction_grid.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"data frame 8,092,995 rows three variables: site_id Unique point identifier. Arbitrarily generated. lon Longitude lat Latitude","code":""},{"path":"https://docs.ropensci.org/chopin/reference/prediction_grid.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"Mainland United States polygon obtained US Census Bureau.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/prediction_grid.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"Coordinates EPSG:5070 (Conus Albers Equal Area)","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/prediction_grid.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Regular grid points in the mainland United States at 1km spatial resolution — prediction_grid","text":"","code":"data(\"prediction_grid\", package = \"chopin\")"},{"path":"https://docs.ropensci.org/chopin/reference/reproject_std.html","id":null,"dir":"Reference","previous_headings":"","what":"Check coordinate system then reproject — reproject_std","title":"Check coordinate system then reproject — reproject_std","text":"input checked whether coordinate system present. , reprojected CRS specified crs_standard.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/reproject_std.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check coordinate system then reproject — reproject_std","text":"","code":"reproject_std(input, crs_standard = \"EPSG:4326\")"},{"path":"https://docs.ropensci.org/chopin/reference/reproject_std.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check coordinate system then reproject — reproject_std","text":"input Input object one sf terra::Spat* object crs_standard character(1). standard definition coordinate reference system. Default \"EPSG:4326\" Consult epsg.io details CRS.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/reproject_std.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check coordinate system then reproject — reproject_std","text":"(reprojected) sf SpatVector object.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/reproject_std.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Check coordinate system then reproject — reproject_std","text":"function works well EPSG codes.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/reproject_std.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Check coordinate system then reproject — reproject_std","text":"Insang Song","code":""},{"path":"https://docs.ropensci.org/chopin/reference/reproject_std.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check coordinate system then reproject — reproject_std","text":"","code":"if (FALSE) { # \\dontrun{ library(sf) library(terra) options(sf_use_s2 = FALSE)  base_crs <- \"EPSG:5070\" nc_path <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc_sf <- sf::st_read(nc_path) reproject_std(nc_sf, base_crs)  nc_vect <- terra::vect(nc_sf) reproject_std(nc_vect, base_crs) } # }"},{"path":"https://docs.ropensci.org/chopin/reference/reproject_to_raster.html","id":null,"dir":"Reference","previous_headings":"","what":"Align vector CRS to raster's — reproject_to_raster","title":"Align vector CRS to raster's — reproject_to_raster","text":"Align vector CRS raster's","code":""},{"path":"https://docs.ropensci.org/chopin/reference/reproject_to_raster.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Align vector CRS to raster's — reproject_to_raster","text":"","code":"reproject_to_raster(vector = NULL, raster = NULL)"},{"path":"https://docs.ropensci.org/chopin/reference/reproject_to_raster.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Align vector CRS to raster's — reproject_to_raster","text":"vector sf/stars/SpatVector/SpatRaster object raster SpatRaster object","code":""},{"path":"https://docs.ropensci.org/chopin/reference/reproject_to_raster.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Align vector CRS to raster's — reproject_to_raster","text":"Reprojected object class vector","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/reproject_to_raster.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Align vector CRS to raster's — reproject_to_raster","text":"Insang Song","code":""},{"path":"https://docs.ropensci.org/chopin/reference/reproject_to_raster.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Align vector CRS to raster's — reproject_to_raster","text":"","code":"if (FALSE) { # \\dontrun{ library(terra) library(sf) options(sf_use_s2 = FALSE)  ncpath <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") elev <- system.file(\"ex/elev.tif\", package = \"terra\") nc <- terra::vect(ncpath) elev <- terra::rast(elev) reproject_to_raster(nc, elev) } # }"},{"path":"https://docs.ropensci.org/chopin/reference/summarize_aw.html","id":null,"dir":"Reference","previous_headings":"","what":"Area weighted summary using two polygon objects — summarize_aw","title":"Area weighted summary using two polygon objects — summarize_aw","text":"x y different classes, poly_weight converted class x.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/summarize_aw.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Area weighted summary using two polygon objects — summarize_aw","text":"","code":"summarize_aw(x, y, ...)  # S4 method for class 'SpatVector,SpatVector' summarize_aw(   x,   y,   target_fields = NULL,   id_x = \"ID\",   fun = stats::weighted.mean,   extent = NULL,   ... )  # S4 method for class 'character,character' summarize_aw(   x,   y,   target_fields = NULL,   id_x = \"ID\",   fun = stats::weighted.mean,   out_class = \"terra\",   extent = NULL,   ... )  # S4 method for class 'sf,sf' summarize_aw(   x,   y,   target_fields = NULL,   id_x = \"ID\",   fun = NULL,   extent = NULL,   ... )"},{"path":"https://docs.ropensci.org/chopin/reference/summarize_aw.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Area weighted summary using two polygon objects — summarize_aw","text":"x sf/SpatVector object file path polygons detectable GDAL driver weighted means calculated. y sf/SpatVector object file path polygons weighted means calculated. ... Additional arguments depending class x y. target_fields character. Field names calculate area-weighted. id_x character(1). unique identifier polygon x. Default \"ID\". fun function(1)/character(1). function calculate weighted summary. Default stats::weighted.mean. function must w argument. x y sf, one c(\"sum\", \"mean\"). determine extensive argument sf::st_interpolate_aw. extent numeric(4) SpatExtent object. Extent clipping x. works x character(1) file path. See terra::ext details. Coordinate systems match. out_class character(1). \"sf\" \"terra\". Output class.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/summarize_aw.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Area weighted summary using two polygon objects — summarize_aw","text":"data.frame numeric fields area-weighted means.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/summarize_aw.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Area weighted summary using two polygon objects — summarize_aw","text":"x y classes match. x y characters, read sf objects.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/summarize_aw.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Area weighted summary using two polygon objects — summarize_aw","text":"Insang Song geoissong@gmail.com","code":""},{"path":"https://docs.ropensci.org/chopin/reference/summarize_aw.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Area weighted summary using two polygon objects — summarize_aw","text":"","code":"# package library(sf) options(sf_use_s2 = FALSE) nc <- sf::st_read(system.file(\"shape/nc.shp\", package=\"sf\")) #> Reading layer `nc' from data source  #>   `/usr/local/lib/R/site-library/sf/shape/nc.shp' using driver `ESRI Shapefile' #> Simple feature collection with 100 features and 14 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: -84.32385 ymin: 33.88199 xmax: -75.45698 ymax: 36.58965 #> Geodetic CRS:  NAD27 nc <- sf::st_transform(nc, 5070) pp <- sf::st_sample(nc, size = 300) pp <- sf::st_as_sf(pp) pp[[\"id\"]] <- seq(1, nrow(pp)) sf::st_crs(pp) <- \"EPSG:5070\" ppb <- sf::st_buffer(pp, nQuadSegs=180, dist = units::set_units(20, \"km\"))  system.time(   ppb_nc_aw <-     summarize_aw(       ppb, nc, c(\"BIR74\", \"BIR79\"),       \"id\", fun = \"sum\"     ) ) #> Warning: st_interpolate_aw assumes attributes are constant or uniform over areas of x #>    user  system elapsed  #>   0.403   0.000   0.403  summary(ppb_nc_aw) #>      BIR74              BIR79                  geometry   #>  Min.   :   52.34   Min.   :  106.4   POLYGON      :300   #>  1st Qu.: 1431.93   1st Qu.: 1743.3   epsg:5070    :  0   #>  Median : 2522.97   Median : 3122.3   +proj=aea ...:  0   #>  Mean   : 3069.54   Mean   : 3927.5                       #>  3rd Qu.: 3984.55   3rd Qu.: 4983.8                       #>  Max.   :13683.47   Max.   :19424.4                        # terra examples library(terra) ncpath <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") elev <- system.file(\"ex/elev.tif\", package = \"terra\") nc <- terra::vect(ncpath) elev <- terra::rast(elev) pp <- terra::spatSample(nc, size = 300) pp <- terra::project(pp, crs(elev)) pp <- terra::as.points(pp) #> Warning: [as.points] returning a copy pp[[\"id\"]] <- seq(1, nrow(pp)) ppb <- terra::buffer(pp, 20000)  system.time(   ppb_nc_aw <-     summarize_aw(       ppb, nc, c(\"BIR74\", \"BIR79\"), \"id\",       fun = sum     ) ) #> Warning: [intersect] different crs #>    user  system elapsed  #>   0.077   0.000   0.078  summary(ppb_nc_aw) #>        id             BIR74               BIR79           #>  Min.   :  1.00   Min.   :2.464e+08   Min.   :2.464e+08   #>  1st Qu.: 75.75   1st Qu.:1.153e+09   1st Qu.:1.153e+09   #>  Median :150.50   Median :1.251e+09   Median :1.251e+09   #>  Mean   :150.50   Mean   :1.147e+09   Mean   :1.147e+09   #>  3rd Qu.:225.25   3rd Qu.:1.251e+09   3rd Qu.:1.251e+09   #>  Max.   :300.00   Max.   :1.252e+09   Max.   :1.252e+09"},{"path":"https://docs.ropensci.org/chopin/reference/summarize_sedc.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"Calculate Sum Exponentially Decaying Contributions (SEDC) covariates","code":""},{"path":"https://docs.ropensci.org/chopin/reference/summarize_sedc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"","code":"summarize_sedc(   point_from = NULL,   point_to = NULL,   id = NULL,   sedc_bandwidth = NULL,   threshold = NULL,   target_fields = NULL,   extent_from = NULL,   extent_to = NULL,   ... )"},{"path":"https://docs.ropensci.org/chopin/reference/summarize_sedc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"point_from SpatVector object. Locations sum SEDCs calculated. point_to SpatVector object. Locations SEDC calculated. id character(1). Name unique id field point_to. sedc_bandwidth numeric(1). Distance source concentration reduced exp(-3) (approximately -95 %) threshold numeric(1). computational efficiency, nearest points threshold selected. 2 * sedc_bandwidth applied value remains NULL. target_fields character. Field names calculate SEDC. extent_from numeric(4) SpatExtent. Extent clipping point_from. works point_from character(1) file path. See terra::ext details. Coordinate systems match. extent_to numeric(4) SpatExtent. Extent clipping point_to. ... Placeholder.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/summarize_sedc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"data.frame object input field names suffix \"_sedc\" sums EDC stored. Additional attributes attached EDC information. attr(result, \"sedc_bandwidth\"): bandwidth concentration reduces approximately five percent attr(result, \"sedc_threshold\"): threshold distance emission source points excluded beyond ","code":""},{"path":"https://docs.ropensci.org/chopin/reference/summarize_sedc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"SEDC specialized vector vector summary covariates exponential decay. Decaying slope defined sedc_bandwidth, concentration source reduced $\\exp(-3)$ (approximately 5 \\ attenuating concentration distance sources. can thought fixed bandwidth kernel weighted sum covariates, encapsulates three steps: Calculate distance source target points. Calculate weight source point exponential decay. Summarize weighted covariates.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/summarize_sedc.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"Distance calculation done terra functions internally. Thus, function internally converts sf objects point_* arguments terra. Please note NA values input ignored SEDC calculation.","code":""},{"path":"https://docs.ropensci.org/chopin/reference/summarize_sedc.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"Messier KP, Akita Y, Serre ML. (2012). Integrating Address Geocoding, Land Use Regression, Spatiotemporal Geostatistical Estimation Groundwater Tetrachloroethylene. Environmental Science & Technology 46(5), 2772-2780. Wiesner C. (n.d.). Euclidean Sum Exponentially Decaying Contributions Tutorial.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/chopin/reference/summarize_sedc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"Insang Song","code":""},{"path":"https://docs.ropensci.org/chopin/reference/summarize_sedc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate Sum of Exponentially Decaying Contributions (SEDC) covariates — summarize_sedc","text":"","code":"library(terra) library(sf) set.seed(101) ncpath <- system.file(\"gpkg/nc.gpkg\", package = \"sf\") nc <- terra::vect(ncpath) nc <- terra::project(nc, \"EPSG:5070\") pnt_from <- terra::centroids(nc, inside = TRUE) pnt_from <- pnt_from[, \"NAME\"] pnt_to <- terra::spatSample(nc, 100L) pnt_to$pid <- seq(1, 100) pnt_to <- pnt_to[, \"pid\"] pnt_to$val1 <- rgamma(100L, 1, 0.05) pnt_to$val2 <- rgamma(100L, 2, 1)  vals <- c(\"val1\", \"val2\") summarize_sedc(pnt_from, pnt_to, \"NAME\", 1e5, 2e5, vals) #> # A tibble: 100 × 3 #>    NAME      val1_sedc val2_sedc #>    <chr>         <dbl>     <dbl> #>  1 Alamance       66.3      6.71 #>  2 Alexander      98.0     11.7  #>  3 Alleghany     135.       8.57 #>  4 Anson          50.0      5.23 #>  5 Ashe          143.       8.42 #>  6 Avery          76.1      8.76 #>  7 Beaufort       58.8      6.29 #>  8 Bertie         70.1      7.85 #>  9 Bladen         79.5      6.82 #> 10 Brunswick      54.3      5.34 #> # ℹ 90 more rows"}]
